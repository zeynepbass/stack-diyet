{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isAbsolute = exports.partitionAbsoluteAndRelative = exports.removeDuplicateSlashes = exports.matchAny = exports.convertPatternsToRe = exports.makeRe = exports.getPatternParts = exports.expandBraceExpansion = exports.expandPatternsWithBraceExpansion = exports.isAffectDepthOfReadingPattern = exports.endsWithSlashGlobStar = exports.hasGlobStar = exports.getBaseDirectory = exports.isPatternRelatedToParentDirectory = exports.getPatternsOutsideCurrentDirectory = exports.getPatternsInsideCurrentDirectory = exports.getPositivePatterns = exports.getNegativePatterns = exports.isPositivePattern = exports.isNegativePattern = exports.convertToNegativePattern = exports.convertToPositivePattern = exports.isDynamicPattern = exports.isStaticPattern = void 0;\nconst path = require(\"path\");\nconst globParent = require(\"glob-parent\");\nconst micromatch = require(\"micromatch\");\nconst GLOBSTAR = '**';\nconst ESCAPE_SYMBOL = '\\\\';\nconst COMMON_GLOB_SYMBOLS_RE = /[*?]|^!/;\nconst REGEX_CHARACTER_CLASS_SYMBOLS_RE = /\\[[^[]*]/;\nconst REGEX_GROUP_SYMBOLS_RE = /(?:^|[^!*+?@])\\([^(]*\\|[^|]*\\)/;\nconst GLOB_EXTENSION_SYMBOLS_RE = /[!*+?@]\\([^(]*\\)/;\nconst BRACE_EXPANSION_SEPARATORS_RE = /,|\\.\\./;\n/**\n * Matches a sequence of two or more consecutive slashes, excluding the first two slashes at the beginning of the string.\n * The latter is due to the presence of the device path at the beginning of the UNC path.\n */\nconst DOUBLE_SLASH_RE = /(?!^)\\/{2,}/g;\nfunction isStaticPattern(pattern, options = {}) {\n  return !isDynamicPattern(pattern, options);\n}\nexports.isStaticPattern = isStaticPattern;\nfunction isDynamicPattern(pattern, options = {}) {\n  /**\n   * A special case with an empty string is necessary for matching patterns that start with a forward slash.\n   * An empty string cannot be a dynamic pattern.\n   * For example, the pattern `/lib/*` will be spread into parts: '', 'lib', '*'.\n   */\n  if (pattern === '') {\n    return false;\n  }\n  /**\n   * When the `caseSensitiveMatch` option is disabled, all patterns must be marked as dynamic, because we cannot check\n   * filepath directly (without read directory).\n   */\n  if (options.caseSensitiveMatch === false || pattern.includes(ESCAPE_SYMBOL)) {\n    return true;\n  }\n  if (COMMON_GLOB_SYMBOLS_RE.test(pattern) || REGEX_CHARACTER_CLASS_SYMBOLS_RE.test(pattern) || REGEX_GROUP_SYMBOLS_RE.test(pattern)) {\n    return true;\n  }\n  if (options.extglob !== false && GLOB_EXTENSION_SYMBOLS_RE.test(pattern)) {\n    return true;\n  }\n  if (options.braceExpansion !== false && hasBraceExpansion(pattern)) {\n    return true;\n  }\n  return false;\n}\nexports.isDynamicPattern = isDynamicPattern;\nfunction hasBraceExpansion(pattern) {\n  const openingBraceIndex = pattern.indexOf('{');\n  if (openingBraceIndex === -1) {\n    return false;\n  }\n  const closingBraceIndex = pattern.indexOf('}', openingBraceIndex + 1);\n  if (closingBraceIndex === -1) {\n    return false;\n  }\n  const braceContent = pattern.slice(openingBraceIndex, closingBraceIndex);\n  return BRACE_EXPANSION_SEPARATORS_RE.test(braceContent);\n}\nfunction convertToPositivePattern(pattern) {\n  return isNegativePattern(pattern) ? pattern.slice(1) : pattern;\n}\nexports.convertToPositivePattern = convertToPositivePattern;\nfunction convertToNegativePattern(pattern) {\n  return '!' + pattern;\n}\nexports.convertToNegativePattern = convertToNegativePattern;\nfunction isNegativePattern(pattern) {\n  return pattern.startsWith('!') && pattern[1] !== '(';\n}\nexports.isNegativePattern = isNegativePattern;\nfunction isPositivePattern(pattern) {\n  return !isNegativePattern(pattern);\n}\nexports.isPositivePattern = isPositivePattern;\nfunction getNegativePatterns(patterns) {\n  return patterns.filter(isNegativePattern);\n}\nexports.getNegativePatterns = getNegativePatterns;\nfunction getPositivePatterns(patterns) {\n  return patterns.filter(isPositivePattern);\n}\nexports.getPositivePatterns = getPositivePatterns;\n/**\n * Returns patterns that can be applied inside the current directory.\n *\n * @example\n * // ['./*', '*', 'a/*']\n * getPatternsInsideCurrentDirectory(['./*', '*', 'a/*', '../*', './../*'])\n */\nfunction getPatternsInsideCurrentDirectory(patterns) {\n  return patterns.filter(pattern => !isPatternRelatedToParentDirectory(pattern));\n}\nexports.getPatternsInsideCurrentDirectory = getPatternsInsideCurrentDirectory;\n/**\n * Returns patterns to be expanded relative to (outside) the current directory.\n *\n * @example\n * // ['../*', './../*']\n * getPatternsInsideCurrentDirectory(['./*', '*', 'a/*', '../*', './../*'])\n */\nfunction getPatternsOutsideCurrentDirectory(patterns) {\n  return patterns.filter(isPatternRelatedToParentDirectory);\n}\nexports.getPatternsOutsideCurrentDirectory = getPatternsOutsideCurrentDirectory;\nfunction isPatternRelatedToParentDirectory(pattern) {\n  return pattern.startsWith('..') || pattern.startsWith('./..');\n}\nexports.isPatternRelatedToParentDirectory = isPatternRelatedToParentDirectory;\nfunction getBaseDirectory(pattern) {\n  return globParent(pattern, {\n    flipBackslashes: false\n  });\n}\nexports.getBaseDirectory = getBaseDirectory;\nfunction hasGlobStar(pattern) {\n  return pattern.includes(GLOBSTAR);\n}\nexports.hasGlobStar = hasGlobStar;\nfunction endsWithSlashGlobStar(pattern) {\n  return pattern.endsWith('/' + GLOBSTAR);\n}\nexports.endsWithSlashGlobStar = endsWithSlashGlobStar;\nfunction isAffectDepthOfReadingPattern(pattern) {\n  const basename = path.basename(pattern);\n  return endsWithSlashGlobStar(pattern) || isStaticPattern(basename);\n}\nexports.isAffectDepthOfReadingPattern = isAffectDepthOfReadingPattern;\nfunction expandPatternsWithBraceExpansion(patterns) {\n  return patterns.reduce((collection, pattern) => {\n    return collection.concat(expandBraceExpansion(pattern));\n  }, []);\n}\nexports.expandPatternsWithBraceExpansion = expandPatternsWithBraceExpansion;\nfunction expandBraceExpansion(pattern) {\n  const patterns = micromatch.braces(pattern, {\n    expand: true,\n    nodupes: true,\n    keepEscaping: true\n  });\n  /**\n   * Sort the patterns by length so that the same depth patterns are processed side by side.\n   * `a/{b,}/{c,}/*` – `['a///*', 'a/b//*', 'a//c/*', 'a/b/c/*']`\n   */\n  patterns.sort((a, b) => a.length - b.length);\n  /**\n   * Micromatch can return an empty string in the case of patterns like `{a,}`.\n   */\n  return patterns.filter(pattern => pattern !== '');\n}\nexports.expandBraceExpansion = expandBraceExpansion;\nfunction getPatternParts(pattern, options) {\n  let {\n    parts\n  } = micromatch.scan(pattern, Object.assign(Object.assign({}, options), {\n    parts: true\n  }));\n  /**\n   * The scan method returns an empty array in some cases.\n   * See micromatch/picomatch#58 for more details.\n   */\n  if (parts.length === 0) {\n    parts = [pattern];\n  }\n  /**\n   * The scan method does not return an empty part for the pattern with a forward slash.\n   * This is another part of micromatch/picomatch#58.\n   */\n  if (parts[0].startsWith('/')) {\n    parts[0] = parts[0].slice(1);\n    parts.unshift('');\n  }\n  return parts;\n}\nexports.getPatternParts = getPatternParts;\nfunction makeRe(pattern, options) {\n  return micromatch.makeRe(pattern, options);\n}\nexports.makeRe = makeRe;\nfunction convertPatternsToRe(patterns, options) {\n  return patterns.map(pattern => makeRe(pattern, options));\n}\nexports.convertPatternsToRe = convertPatternsToRe;\nfunction matchAny(entry, patternsRe) {\n  return patternsRe.some(patternRe => patternRe.test(entry));\n}\nexports.matchAny = matchAny;\n/**\n * This package only works with forward slashes as a path separator.\n * Because of this, we cannot use the standard `path.normalize` method, because on Windows platform it will use of backslashes.\n */\nfunction removeDuplicateSlashes(pattern) {\n  return pattern.replace(DOUBLE_SLASH_RE, '/');\n}\nexports.removeDuplicateSlashes = removeDuplicateSlashes;\nfunction partitionAbsoluteAndRelative(patterns) {\n  const absolute = [];\n  const relative = [];\n  for (const pattern of patterns) {\n    if (isAbsolute(pattern)) {\n      absolute.push(pattern);\n    } else {\n      relative.push(pattern);\n    }\n  }\n  return [absolute, relative];\n}\nexports.partitionAbsoluteAndRelative = partitionAbsoluteAndRelative;\nfunction isAbsolute(pattern) {\n  return path.isAbsolute(pattern);\n}\nexports.isAbsolute = isAbsolute;","map":{"version":3,"names":["Object","defineProperty","exports","value","isAbsolute","partitionAbsoluteAndRelative","removeDuplicateSlashes","matchAny","convertPatternsToRe","makeRe","getPatternParts","expandBraceExpansion","expandPatternsWithBraceExpansion","isAffectDepthOfReadingPattern","endsWithSlashGlobStar","hasGlobStar","getBaseDirectory","isPatternRelatedToParentDirectory","getPatternsOutsideCurrentDirectory","getPatternsInsideCurrentDirectory","getPositivePatterns","getNegativePatterns","isPositivePattern","isNegativePattern","convertToNegativePattern","convertToPositivePattern","isDynamicPattern","isStaticPattern","path","require","globParent","micromatch","GLOBSTAR","ESCAPE_SYMBOL","COMMON_GLOB_SYMBOLS_RE","REGEX_CHARACTER_CLASS_SYMBOLS_RE","REGEX_GROUP_SYMBOLS_RE","GLOB_EXTENSION_SYMBOLS_RE","BRACE_EXPANSION_SEPARATORS_RE","DOUBLE_SLASH_RE","pattern","options","caseSensitiveMatch","includes","test","extglob","braceExpansion","hasBraceExpansion","openingBraceIndex","indexOf","closingBraceIndex","braceContent","slice","startsWith","patterns","filter","flipBackslashes","endsWith","basename","reduce","collection","concat","braces","expand","nodupes","keepEscaping","sort","a","b","length","parts","scan","assign","unshift","map","entry","patternsRe","some","patternRe","replace","absolute","relative","push"],"sources":["/Users/zeynepbas/Desktop/stackowerflow/node_modules/fast-glob/out/utils/pattern.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isAbsolute = exports.partitionAbsoluteAndRelative = exports.removeDuplicateSlashes = exports.matchAny = exports.convertPatternsToRe = exports.makeRe = exports.getPatternParts = exports.expandBraceExpansion = exports.expandPatternsWithBraceExpansion = exports.isAffectDepthOfReadingPattern = exports.endsWithSlashGlobStar = exports.hasGlobStar = exports.getBaseDirectory = exports.isPatternRelatedToParentDirectory = exports.getPatternsOutsideCurrentDirectory = exports.getPatternsInsideCurrentDirectory = exports.getPositivePatterns = exports.getNegativePatterns = exports.isPositivePattern = exports.isNegativePattern = exports.convertToNegativePattern = exports.convertToPositivePattern = exports.isDynamicPattern = exports.isStaticPattern = void 0;\nconst path = require(\"path\");\nconst globParent = require(\"glob-parent\");\nconst micromatch = require(\"micromatch\");\nconst GLOBSTAR = '**';\nconst ESCAPE_SYMBOL = '\\\\';\nconst COMMON_GLOB_SYMBOLS_RE = /[*?]|^!/;\nconst REGEX_CHARACTER_CLASS_SYMBOLS_RE = /\\[[^[]*]/;\nconst REGEX_GROUP_SYMBOLS_RE = /(?:^|[^!*+?@])\\([^(]*\\|[^|]*\\)/;\nconst GLOB_EXTENSION_SYMBOLS_RE = /[!*+?@]\\([^(]*\\)/;\nconst BRACE_EXPANSION_SEPARATORS_RE = /,|\\.\\./;\n/**\n * Matches a sequence of two or more consecutive slashes, excluding the first two slashes at the beginning of the string.\n * The latter is due to the presence of the device path at the beginning of the UNC path.\n */\nconst DOUBLE_SLASH_RE = /(?!^)\\/{2,}/g;\nfunction isStaticPattern(pattern, options = {}) {\n    return !isDynamicPattern(pattern, options);\n}\nexports.isStaticPattern = isStaticPattern;\nfunction isDynamicPattern(pattern, options = {}) {\n    /**\n     * A special case with an empty string is necessary for matching patterns that start with a forward slash.\n     * An empty string cannot be a dynamic pattern.\n     * For example, the pattern `/lib/*` will be spread into parts: '', 'lib', '*'.\n     */\n    if (pattern === '') {\n        return false;\n    }\n    /**\n     * When the `caseSensitiveMatch` option is disabled, all patterns must be marked as dynamic, because we cannot check\n     * filepath directly (without read directory).\n     */\n    if (options.caseSensitiveMatch === false || pattern.includes(ESCAPE_SYMBOL)) {\n        return true;\n    }\n    if (COMMON_GLOB_SYMBOLS_RE.test(pattern) || REGEX_CHARACTER_CLASS_SYMBOLS_RE.test(pattern) || REGEX_GROUP_SYMBOLS_RE.test(pattern)) {\n        return true;\n    }\n    if (options.extglob !== false && GLOB_EXTENSION_SYMBOLS_RE.test(pattern)) {\n        return true;\n    }\n    if (options.braceExpansion !== false && hasBraceExpansion(pattern)) {\n        return true;\n    }\n    return false;\n}\nexports.isDynamicPattern = isDynamicPattern;\nfunction hasBraceExpansion(pattern) {\n    const openingBraceIndex = pattern.indexOf('{');\n    if (openingBraceIndex === -1) {\n        return false;\n    }\n    const closingBraceIndex = pattern.indexOf('}', openingBraceIndex + 1);\n    if (closingBraceIndex === -1) {\n        return false;\n    }\n    const braceContent = pattern.slice(openingBraceIndex, closingBraceIndex);\n    return BRACE_EXPANSION_SEPARATORS_RE.test(braceContent);\n}\nfunction convertToPositivePattern(pattern) {\n    return isNegativePattern(pattern) ? pattern.slice(1) : pattern;\n}\nexports.convertToPositivePattern = convertToPositivePattern;\nfunction convertToNegativePattern(pattern) {\n    return '!' + pattern;\n}\nexports.convertToNegativePattern = convertToNegativePattern;\nfunction isNegativePattern(pattern) {\n    return pattern.startsWith('!') && pattern[1] !== '(';\n}\nexports.isNegativePattern = isNegativePattern;\nfunction isPositivePattern(pattern) {\n    return !isNegativePattern(pattern);\n}\nexports.isPositivePattern = isPositivePattern;\nfunction getNegativePatterns(patterns) {\n    return patterns.filter(isNegativePattern);\n}\nexports.getNegativePatterns = getNegativePatterns;\nfunction getPositivePatterns(patterns) {\n    return patterns.filter(isPositivePattern);\n}\nexports.getPositivePatterns = getPositivePatterns;\n/**\n * Returns patterns that can be applied inside the current directory.\n *\n * @example\n * // ['./*', '*', 'a/*']\n * getPatternsInsideCurrentDirectory(['./*', '*', 'a/*', '../*', './../*'])\n */\nfunction getPatternsInsideCurrentDirectory(patterns) {\n    return patterns.filter((pattern) => !isPatternRelatedToParentDirectory(pattern));\n}\nexports.getPatternsInsideCurrentDirectory = getPatternsInsideCurrentDirectory;\n/**\n * Returns patterns to be expanded relative to (outside) the current directory.\n *\n * @example\n * // ['../*', './../*']\n * getPatternsInsideCurrentDirectory(['./*', '*', 'a/*', '../*', './../*'])\n */\nfunction getPatternsOutsideCurrentDirectory(patterns) {\n    return patterns.filter(isPatternRelatedToParentDirectory);\n}\nexports.getPatternsOutsideCurrentDirectory = getPatternsOutsideCurrentDirectory;\nfunction isPatternRelatedToParentDirectory(pattern) {\n    return pattern.startsWith('..') || pattern.startsWith('./..');\n}\nexports.isPatternRelatedToParentDirectory = isPatternRelatedToParentDirectory;\nfunction getBaseDirectory(pattern) {\n    return globParent(pattern, { flipBackslashes: false });\n}\nexports.getBaseDirectory = getBaseDirectory;\nfunction hasGlobStar(pattern) {\n    return pattern.includes(GLOBSTAR);\n}\nexports.hasGlobStar = hasGlobStar;\nfunction endsWithSlashGlobStar(pattern) {\n    return pattern.endsWith('/' + GLOBSTAR);\n}\nexports.endsWithSlashGlobStar = endsWithSlashGlobStar;\nfunction isAffectDepthOfReadingPattern(pattern) {\n    const basename = path.basename(pattern);\n    return endsWithSlashGlobStar(pattern) || isStaticPattern(basename);\n}\nexports.isAffectDepthOfReadingPattern = isAffectDepthOfReadingPattern;\nfunction expandPatternsWithBraceExpansion(patterns) {\n    return patterns.reduce((collection, pattern) => {\n        return collection.concat(expandBraceExpansion(pattern));\n    }, []);\n}\nexports.expandPatternsWithBraceExpansion = expandPatternsWithBraceExpansion;\nfunction expandBraceExpansion(pattern) {\n    const patterns = micromatch.braces(pattern, { expand: true, nodupes: true, keepEscaping: true });\n    /**\n     * Sort the patterns by length so that the same depth patterns are processed side by side.\n     * `a/{b,}/{c,}/*` – `['a///*', 'a/b//*', 'a//c/*', 'a/b/c/*']`\n     */\n    patterns.sort((a, b) => a.length - b.length);\n    /**\n     * Micromatch can return an empty string in the case of patterns like `{a,}`.\n     */\n    return patterns.filter((pattern) => pattern !== '');\n}\nexports.expandBraceExpansion = expandBraceExpansion;\nfunction getPatternParts(pattern, options) {\n    let { parts } = micromatch.scan(pattern, Object.assign(Object.assign({}, options), { parts: true }));\n    /**\n     * The scan method returns an empty array in some cases.\n     * See micromatch/picomatch#58 for more details.\n     */\n    if (parts.length === 0) {\n        parts = [pattern];\n    }\n    /**\n     * The scan method does not return an empty part for the pattern with a forward slash.\n     * This is another part of micromatch/picomatch#58.\n     */\n    if (parts[0].startsWith('/')) {\n        parts[0] = parts[0].slice(1);\n        parts.unshift('');\n    }\n    return parts;\n}\nexports.getPatternParts = getPatternParts;\nfunction makeRe(pattern, options) {\n    return micromatch.makeRe(pattern, options);\n}\nexports.makeRe = makeRe;\nfunction convertPatternsToRe(patterns, options) {\n    return patterns.map((pattern) => makeRe(pattern, options));\n}\nexports.convertPatternsToRe = convertPatternsToRe;\nfunction matchAny(entry, patternsRe) {\n    return patternsRe.some((patternRe) => patternRe.test(entry));\n}\nexports.matchAny = matchAny;\n/**\n * This package only works with forward slashes as a path separator.\n * Because of this, we cannot use the standard `path.normalize` method, because on Windows platform it will use of backslashes.\n */\nfunction removeDuplicateSlashes(pattern) {\n    return pattern.replace(DOUBLE_SLASH_RE, '/');\n}\nexports.removeDuplicateSlashes = removeDuplicateSlashes;\nfunction partitionAbsoluteAndRelative(patterns) {\n    const absolute = [];\n    const relative = [];\n    for (const pattern of patterns) {\n        if (isAbsolute(pattern)) {\n            absolute.push(pattern);\n        }\n        else {\n            relative.push(pattern);\n        }\n    }\n    return [absolute, relative];\n}\nexports.partitionAbsoluteAndRelative = partitionAbsoluteAndRelative;\nfunction isAbsolute(pattern) {\n    return path.isAbsolute(pattern);\n}\nexports.isAbsolute = isAbsolute;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}