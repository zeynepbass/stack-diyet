{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst utils = require(\"../../utils\");\nclass EntryFilter {\n  constructor(_settings, _micromatchOptions) {\n    this._settings = _settings;\n    this._micromatchOptions = _micromatchOptions;\n    this.index = new Map();\n  }\n  getFilter(positive, negative) {\n    const [absoluteNegative, relativeNegative] = utils.pattern.partitionAbsoluteAndRelative(negative);\n    const patterns = {\n      positive: {\n        all: utils.pattern.convertPatternsToRe(positive, this._micromatchOptions)\n      },\n      negative: {\n        absolute: utils.pattern.convertPatternsToRe(absoluteNegative, Object.assign(Object.assign({}, this._micromatchOptions), {\n          dot: true\n        })),\n        relative: utils.pattern.convertPatternsToRe(relativeNegative, Object.assign(Object.assign({}, this._micromatchOptions), {\n          dot: true\n        }))\n      }\n    };\n    return entry => this._filter(entry, patterns);\n  }\n  _filter(entry, patterns) {\n    const filepath = utils.path.removeLeadingDotSegment(entry.path);\n    if (this._settings.unique && this._isDuplicateEntry(filepath)) {\n      return false;\n    }\n    if (this._onlyFileFilter(entry) || this._onlyDirectoryFilter(entry)) {\n      return false;\n    }\n    const isMatched = this._isMatchToPatternsSet(filepath, patterns, entry.dirent.isDirectory());\n    if (this._settings.unique && isMatched) {\n      this._createIndexRecord(filepath);\n    }\n    return isMatched;\n  }\n  _isDuplicateEntry(filepath) {\n    return this.index.has(filepath);\n  }\n  _createIndexRecord(filepath) {\n    this.index.set(filepath, undefined);\n  }\n  _onlyFileFilter(entry) {\n    return this._settings.onlyFiles && !entry.dirent.isFile();\n  }\n  _onlyDirectoryFilter(entry) {\n    return this._settings.onlyDirectories && !entry.dirent.isDirectory();\n  }\n  _isMatchToPatternsSet(filepath, patterns, isDirectory) {\n    const isMatched = this._isMatchToPatterns(filepath, patterns.positive.all, isDirectory);\n    if (!isMatched) {\n      return false;\n    }\n    const isMatchedByRelativeNegative = this._isMatchToPatterns(filepath, patterns.negative.relative, isDirectory);\n    if (isMatchedByRelativeNegative) {\n      return false;\n    }\n    const isMatchedByAbsoluteNegative = this._isMatchToAbsoluteNegative(filepath, patterns.negative.absolute, isDirectory);\n    if (isMatchedByAbsoluteNegative) {\n      return false;\n    }\n    return true;\n  }\n  _isMatchToAbsoluteNegative(filepath, patternsRe, isDirectory) {\n    if (patternsRe.length === 0) {\n      return false;\n    }\n    const fullpath = utils.path.makeAbsolute(this._settings.cwd, filepath);\n    return this._isMatchToPatterns(fullpath, patternsRe, isDirectory);\n  }\n  _isMatchToPatterns(filepath, patternsRe, isDirectory) {\n    if (patternsRe.length === 0) {\n      return false;\n    }\n    // Trying to match files and directories by patterns.\n    const isMatched = utils.pattern.matchAny(filepath, patternsRe);\n    // A pattern with a trailling slash can be used for directory matching.\n    // To apply such pattern, we need to add a tralling slash to the path.\n    if (!isMatched && isDirectory) {\n      return utils.pattern.matchAny(filepath + '/', patternsRe);\n    }\n    return isMatched;\n  }\n}\nexports.default = EntryFilter;","map":{"version":3,"names":["Object","defineProperty","exports","value","utils","require","EntryFilter","constructor","_settings","_micromatchOptions","index","Map","getFilter","positive","negative","absoluteNegative","relativeNegative","pattern","partitionAbsoluteAndRelative","patterns","all","convertPatternsToRe","absolute","assign","dot","relative","entry","_filter","filepath","path","removeLeadingDotSegment","unique","_isDuplicateEntry","_onlyFileFilter","_onlyDirectoryFilter","isMatched","_isMatchToPatternsSet","dirent","isDirectory","_createIndexRecord","has","set","undefined","onlyFiles","isFile","onlyDirectories","_isMatchToPatterns","isMatchedByRelativeNegative","isMatchedByAbsoluteNegative","_isMatchToAbsoluteNegative","patternsRe","length","fullpath","makeAbsolute","cwd","matchAny","default"],"sources":["/Users/zeynepbas/Desktop/stackowerflow/node_modules/fast-glob/out/providers/filters/entry.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst utils = require(\"../../utils\");\nclass EntryFilter {\n    constructor(_settings, _micromatchOptions) {\n        this._settings = _settings;\n        this._micromatchOptions = _micromatchOptions;\n        this.index = new Map();\n    }\n    getFilter(positive, negative) {\n        const [absoluteNegative, relativeNegative] = utils.pattern.partitionAbsoluteAndRelative(negative);\n        const patterns = {\n            positive: {\n                all: utils.pattern.convertPatternsToRe(positive, this._micromatchOptions)\n            },\n            negative: {\n                absolute: utils.pattern.convertPatternsToRe(absoluteNegative, Object.assign(Object.assign({}, this._micromatchOptions), { dot: true })),\n                relative: utils.pattern.convertPatternsToRe(relativeNegative, Object.assign(Object.assign({}, this._micromatchOptions), { dot: true }))\n            }\n        };\n        return (entry) => this._filter(entry, patterns);\n    }\n    _filter(entry, patterns) {\n        const filepath = utils.path.removeLeadingDotSegment(entry.path);\n        if (this._settings.unique && this._isDuplicateEntry(filepath)) {\n            return false;\n        }\n        if (this._onlyFileFilter(entry) || this._onlyDirectoryFilter(entry)) {\n            return false;\n        }\n        const isMatched = this._isMatchToPatternsSet(filepath, patterns, entry.dirent.isDirectory());\n        if (this._settings.unique && isMatched) {\n            this._createIndexRecord(filepath);\n        }\n        return isMatched;\n    }\n    _isDuplicateEntry(filepath) {\n        return this.index.has(filepath);\n    }\n    _createIndexRecord(filepath) {\n        this.index.set(filepath, undefined);\n    }\n    _onlyFileFilter(entry) {\n        return this._settings.onlyFiles && !entry.dirent.isFile();\n    }\n    _onlyDirectoryFilter(entry) {\n        return this._settings.onlyDirectories && !entry.dirent.isDirectory();\n    }\n    _isMatchToPatternsSet(filepath, patterns, isDirectory) {\n        const isMatched = this._isMatchToPatterns(filepath, patterns.positive.all, isDirectory);\n        if (!isMatched) {\n            return false;\n        }\n        const isMatchedByRelativeNegative = this._isMatchToPatterns(filepath, patterns.negative.relative, isDirectory);\n        if (isMatchedByRelativeNegative) {\n            return false;\n        }\n        const isMatchedByAbsoluteNegative = this._isMatchToAbsoluteNegative(filepath, patterns.negative.absolute, isDirectory);\n        if (isMatchedByAbsoluteNegative) {\n            return false;\n        }\n        return true;\n    }\n    _isMatchToAbsoluteNegative(filepath, patternsRe, isDirectory) {\n        if (patternsRe.length === 0) {\n            return false;\n        }\n        const fullpath = utils.path.makeAbsolute(this._settings.cwd, filepath);\n        return this._isMatchToPatterns(fullpath, patternsRe, isDirectory);\n    }\n    _isMatchToPatterns(filepath, patternsRe, isDirectory) {\n        if (patternsRe.length === 0) {\n            return false;\n        }\n        // Trying to match files and directories by patterns.\n        const isMatched = utils.pattern.matchAny(filepath, patternsRe);\n        // A pattern with a trailling slash can be used for directory matching.\n        // To apply such pattern, we need to add a tralling slash to the path.\n        if (!isMatched && isDirectory) {\n            return utils.pattern.matchAny(filepath + '/', patternsRe);\n        }\n        return isMatched;\n    }\n}\nexports.default = EntryFilter;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}