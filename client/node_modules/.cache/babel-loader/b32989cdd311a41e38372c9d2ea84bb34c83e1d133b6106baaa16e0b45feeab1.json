{"ast":null,"code":"// @ts-check\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nfunction _export(target, all) {\n  for (var name in all) Object.defineProperty(target, name, {\n    enumerable: true,\n    get: all[name]\n  });\n}\n_export(exports, {\n  parseCandidateFiles: function () {\n    return parseCandidateFiles;\n  },\n  resolvedChangedContent: function () {\n    return resolvedChangedContent;\n  },\n  createBroadPatternCheck: function () {\n    return createBroadPatternCheck;\n  }\n});\nconst _fs = /*#__PURE__*/_interop_require_default(require(\"fs\"));\nconst _path = /*#__PURE__*/_interop_require_default(require(\"path\"));\nconst _isglob = /*#__PURE__*/_interop_require_default(require(\"is-glob\"));\nconst _fastglob = /*#__PURE__*/_interop_require_default(require(\"fast-glob\"));\nconst _normalizepath = /*#__PURE__*/_interop_require_default(require(\"normalize-path\"));\nconst _parseGlob = require(\"../util/parseGlob\");\nconst _sharedState = require(\"./sharedState\");\nconst _log = /*#__PURE__*/_interop_require_default(require(\"../util/log\"));\nconst _micromatch = /*#__PURE__*/_interop_require_default(require(\"micromatch\"));\nfunction _interop_require_default(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction parseCandidateFiles(context, tailwindConfig) {\n  let files = tailwindConfig.content.files;\n  // Normalize the file globs\n  files = files.filter(filePath => typeof filePath === \"string\");\n  files = files.map(_normalizepath.default);\n  // Split into included and excluded globs\n  let tasks = _fastglob.default.generateTasks(files);\n  /** @type {ContentPath[]} */\n  let included = [];\n  /** @type {ContentPath[]} */\n  let excluded = [];\n  for (const task of tasks) {\n    included.push(...task.positive.map(filePath => parseFilePath(filePath, false)));\n    excluded.push(...task.negative.map(filePath => parseFilePath(filePath, true)));\n  }\n  let paths = [...included, ...excluded];\n  // Resolve paths relative to the config file or cwd\n  paths = resolveRelativePaths(context, paths);\n  // Resolve symlinks if possible\n  paths = paths.flatMap(resolvePathSymlinks);\n  // Update cached patterns\n  paths = paths.map(resolveGlobPattern);\n  return paths;\n}\n/**\n *\n * @param {string} filePath\n * @param {boolean} ignore\n * @returns {ContentPath}\n */\nfunction parseFilePath(filePath, ignore) {\n  let contentPath = {\n    original: filePath,\n    base: filePath,\n    ignore,\n    pattern: filePath,\n    glob: null\n  };\n  if ((0, _isglob.default)(filePath)) {\n    Object.assign(contentPath, (0, _parseGlob.parseGlob)(filePath));\n  }\n  return contentPath;\n}\n/**\n *\n * @param {ContentPath} contentPath\n * @returns {ContentPath}\n */\nfunction resolveGlobPattern(contentPath) {\n  // This is required for Windows support to properly pick up Glob paths.\n  // Afaik, this technically shouldn't be needed but there's probably\n  // some internal, direct path matching with a normalized path in\n  // a package which can't handle mixed directory separators\n  let base = (0, _normalizepath.default)(contentPath.base);\n  // If the user's file path contains any special characters (like parens) for instance fast-glob\n  // is like \"OOOH SHINY\" and treats them as such. So we have to escape the base path to fix this\n  base = _fastglob.default.escapePath(base);\n  contentPath.pattern = contentPath.glob ? `${base}/${contentPath.glob}` : base;\n  contentPath.pattern = contentPath.ignore ? `!${contentPath.pattern}` : contentPath.pattern;\n  return contentPath;\n}\n/**\n * Resolve each path relative to the config file (when possible) if the experimental flag is enabled\n * Otherwise, resolve relative to the current working directory\n *\n * @param {any} context\n * @param {ContentPath[]} contentPaths\n * @returns {ContentPath[]}\n */\nfunction resolveRelativePaths(context, contentPaths) {\n  let resolveFrom = [];\n  // Resolve base paths relative to the config file (when possible) if the experimental flag is enabled\n  if (context.userConfigPath && context.tailwindConfig.content.relative) {\n    resolveFrom = [_path.default.dirname(context.userConfigPath)];\n  }\n  return contentPaths.map(contentPath => {\n    contentPath.base = _path.default.resolve(...resolveFrom, contentPath.base);\n    return contentPath;\n  });\n}\n/**\n * Resolve the symlink for the base directory / file in each path\n * These are added as additional dependencies to watch for changes because\n * some tools (like webpack) will only watch the actual file or directory\n * but not the symlink itself even in projects that use monorepos.\n *\n * @param {ContentPath} contentPath\n * @returns {ContentPath[]}\n */\nfunction resolvePathSymlinks(contentPath) {\n  let paths = [contentPath];\n  try {\n    let resolvedPath = _fs.default.realpathSync(contentPath.base);\n    if (resolvedPath !== contentPath.base) {\n      paths.push({\n        ...contentPath,\n        base: resolvedPath\n      });\n    }\n  } catch {\n    // TODO: log this?\n  }\n  return paths;\n}\nfunction resolvedChangedContent(context, candidateFiles, fileModifiedMap) {\n  let changedContent = context.tailwindConfig.content.files.filter(item => typeof item.raw === \"string\").map(({\n    raw,\n    extension = \"html\"\n  }) => ({\n    content: raw,\n    extension\n  }));\n  let [changedFiles, mTimesToCommit] = resolveChangedFiles(candidateFiles, fileModifiedMap);\n  for (let changedFile of changedFiles) {\n    let extension = _path.default.extname(changedFile).slice(1);\n    changedContent.push({\n      file: changedFile,\n      extension\n    });\n  }\n  return [changedContent, mTimesToCommit];\n}\nconst LARGE_DIRECTORIES = [\"node_modules\"];\n// Ensures that `node_modules` has to match as-is, otherwise `mynode_modules`\n// would match as well, but that is not a known large directory.\nconst LARGE_DIRECTORIES_REGEX = new RegExp(`(${LARGE_DIRECTORIES.map(dir => String.raw`\\b${dir}\\b`).join(\"|\")})`);\nfunction createBroadPatternCheck(paths) {\n  // Detect whether a glob pattern might be too broad. This means that it:\n  // - Includes `**`\n  // - Does not include any of the known large directories (e.g.: node_modules)\n  let maybeBroadPattern = paths.some(path => path.includes(\"**\") && !LARGE_DIRECTORIES_REGEX.test(path));\n  // Didn't detect any potentially broad patterns, so we can skip further\n  // checks.\n  if (!maybeBroadPattern) {\n    return () => {};\n  }\n  // All glob matchers\n  let matchers = [];\n  // All glob matchers that explicitly contain any of the known large\n  // directories (e.g.: node_modules).\n  let explicitMatchers = [];\n  // Create matchers for all paths\n  for (let path of paths) {\n    let matcher = _micromatch.default.matcher(path);\n    if (LARGE_DIRECTORIES_REGEX.test(path)) {\n      explicitMatchers.push(matcher);\n    }\n    matchers.push(matcher);\n  }\n  // Keep track of whether we already warned about the broad pattern issue or\n  // not. The `log.warn` function already does something similar where we only\n  // output the log once. However, with this we can also skip the other checks\n  // when we already warned about the broad pattern.\n  let warned = false;\n  /**\n  * @param {string} file\n  */\n  return file => {\n    if (warned) return; // Already warned about the broad pattern\n    if (explicitMatchers.some(matcher => matcher(file))) return; // Explicitly included, so we can skip further checks\n    // When a broad pattern is used, we have to double check that the file was\n    // not explicitly included in the globs.\n    let matchingGlobIndex = matchers.findIndex(matcher => matcher(file));\n    if (matchingGlobIndex === -1) return; // This should never happen\n    let matchingGlob = paths[matchingGlobIndex];\n    // Create relative paths to make the output a bit more readable.\n    let relativeMatchingGlob = _path.default.relative(process.cwd(), matchingGlob);\n    if (relativeMatchingGlob[0] !== \".\") relativeMatchingGlob = `./${relativeMatchingGlob}`;\n    let largeDirectory = LARGE_DIRECTORIES.find(directory => file.includes(directory));\n    if (largeDirectory) {\n      warned = true;\n      _log.default.warn(\"broad-content-glob-pattern\", [`Your \\`content\\` configuration includes a pattern which looks like it's accidentally matching all of \\`${largeDirectory}\\` and can cause serious performance issues.`, `Pattern: \\`${relativeMatchingGlob}\\``, `See our documentation for recommendations:`, \"https://tailwindcss.com/docs/content-configuration#pattern-recommendations\"]);\n    }\n  };\n}\n/**\n *\n * @param {ContentPath[]} candidateFiles\n * @param {Map<string, number>} fileModifiedMap\n * @returns {[Set<string>, Map<string, number>]}\n */\nfunction resolveChangedFiles(candidateFiles, fileModifiedMap) {\n  let paths = candidateFiles.map(contentPath => contentPath.pattern);\n  let mTimesToCommit = new Map();\n  let checkBroadPattern = createBroadPatternCheck(paths);\n  let changedFiles = new Set();\n  _sharedState.env.DEBUG && console.time(\"Finding changed files\");\n  let files = _fastglob.default.sync(paths, {\n    absolute: true\n  });\n  for (let file of files) {\n    checkBroadPattern(file);\n    let prevModified = fileModifiedMap.get(file) || -Infinity;\n    let modified = _fs.default.statSync(file).mtimeMs;\n    if (modified > prevModified) {\n      changedFiles.add(file);\n      mTimesToCommit.set(file, modified);\n    }\n  }\n  _sharedState.env.DEBUG && console.timeEnd(\"Finding changed files\");\n  return [changedFiles, mTimesToCommit];\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","_export","target","all","name","enumerable","get","parseCandidateFiles","resolvedChangedContent","createBroadPatternCheck","_fs","_interop_require_default","require","_path","_isglob","_fastglob","_normalizepath","_parseGlob","_sharedState","_log","_micromatch","obj","__esModule","default","context","tailwindConfig","files","content","filter","filePath","map","tasks","generateTasks","included","excluded","task","push","positive","parseFilePath","negative","paths","resolveRelativePaths","flatMap","resolvePathSymlinks","resolveGlobPattern","ignore","contentPath","original","base","pattern","glob","assign","parseGlob","escapePath","contentPaths","resolveFrom","userConfigPath","relative","dirname","resolve","resolvedPath","realpathSync","candidateFiles","fileModifiedMap","changedContent","item","raw","extension","changedFiles","mTimesToCommit","resolveChangedFiles","changedFile","extname","slice","file","LARGE_DIRECTORIES","LARGE_DIRECTORIES_REGEX","RegExp","dir","String","join","maybeBroadPattern","some","path","includes","test","matchers","explicitMatchers","matcher","warned","matchingGlobIndex","findIndex","matchingGlob","relativeMatchingGlob","process","cwd","largeDirectory","find","directory","warn","Map","checkBroadPattern","Set","env","DEBUG","console","time","sync","absolute","prevModified","Infinity","modified","statSync","mtimeMs","add","set","timeEnd"],"sources":["/Users/zeynepbas/Desktop/stackowerflow/node_modules/tailwindcss/lib/lib/content.js"],"sourcesContent":["// @ts-check\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    parseCandidateFiles: function() {\n        return parseCandidateFiles;\n    },\n    resolvedChangedContent: function() {\n        return resolvedChangedContent;\n    },\n    createBroadPatternCheck: function() {\n        return createBroadPatternCheck;\n    }\n});\nconst _fs = /*#__PURE__*/ _interop_require_default(require(\"fs\"));\nconst _path = /*#__PURE__*/ _interop_require_default(require(\"path\"));\nconst _isglob = /*#__PURE__*/ _interop_require_default(require(\"is-glob\"));\nconst _fastglob = /*#__PURE__*/ _interop_require_default(require(\"fast-glob\"));\nconst _normalizepath = /*#__PURE__*/ _interop_require_default(require(\"normalize-path\"));\nconst _parseGlob = require(\"../util/parseGlob\");\nconst _sharedState = require(\"./sharedState\");\nconst _log = /*#__PURE__*/ _interop_require_default(require(\"../util/log\"));\nconst _micromatch = /*#__PURE__*/ _interop_require_default(require(\"micromatch\"));\nfunction _interop_require_default(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nfunction parseCandidateFiles(context, tailwindConfig) {\n    let files = tailwindConfig.content.files;\n    // Normalize the file globs\n    files = files.filter((filePath)=>typeof filePath === \"string\");\n    files = files.map(_normalizepath.default);\n    // Split into included and excluded globs\n    let tasks = _fastglob.default.generateTasks(files);\n    /** @type {ContentPath[]} */ let included = [];\n    /** @type {ContentPath[]} */ let excluded = [];\n    for (const task of tasks){\n        included.push(...task.positive.map((filePath)=>parseFilePath(filePath, false)));\n        excluded.push(...task.negative.map((filePath)=>parseFilePath(filePath, true)));\n    }\n    let paths = [\n        ...included,\n        ...excluded\n    ];\n    // Resolve paths relative to the config file or cwd\n    paths = resolveRelativePaths(context, paths);\n    // Resolve symlinks if possible\n    paths = paths.flatMap(resolvePathSymlinks);\n    // Update cached patterns\n    paths = paths.map(resolveGlobPattern);\n    return paths;\n}\n/**\n *\n * @param {string} filePath\n * @param {boolean} ignore\n * @returns {ContentPath}\n */ function parseFilePath(filePath, ignore) {\n    let contentPath = {\n        original: filePath,\n        base: filePath,\n        ignore,\n        pattern: filePath,\n        glob: null\n    };\n    if ((0, _isglob.default)(filePath)) {\n        Object.assign(contentPath, (0, _parseGlob.parseGlob)(filePath));\n    }\n    return contentPath;\n}\n/**\n *\n * @param {ContentPath} contentPath\n * @returns {ContentPath}\n */ function resolveGlobPattern(contentPath) {\n    // This is required for Windows support to properly pick up Glob paths.\n    // Afaik, this technically shouldn't be needed but there's probably\n    // some internal, direct path matching with a normalized path in\n    // a package which can't handle mixed directory separators\n    let base = (0, _normalizepath.default)(contentPath.base);\n    // If the user's file path contains any special characters (like parens) for instance fast-glob\n    // is like \"OOOH SHINY\" and treats them as such. So we have to escape the base path to fix this\n    base = _fastglob.default.escapePath(base);\n    contentPath.pattern = contentPath.glob ? `${base}/${contentPath.glob}` : base;\n    contentPath.pattern = contentPath.ignore ? `!${contentPath.pattern}` : contentPath.pattern;\n    return contentPath;\n}\n/**\n * Resolve each path relative to the config file (when possible) if the experimental flag is enabled\n * Otherwise, resolve relative to the current working directory\n *\n * @param {any} context\n * @param {ContentPath[]} contentPaths\n * @returns {ContentPath[]}\n */ function resolveRelativePaths(context, contentPaths) {\n    let resolveFrom = [];\n    // Resolve base paths relative to the config file (when possible) if the experimental flag is enabled\n    if (context.userConfigPath && context.tailwindConfig.content.relative) {\n        resolveFrom = [\n            _path.default.dirname(context.userConfigPath)\n        ];\n    }\n    return contentPaths.map((contentPath)=>{\n        contentPath.base = _path.default.resolve(...resolveFrom, contentPath.base);\n        return contentPath;\n    });\n}\n/**\n * Resolve the symlink for the base directory / file in each path\n * These are added as additional dependencies to watch for changes because\n * some tools (like webpack) will only watch the actual file or directory\n * but not the symlink itself even in projects that use monorepos.\n *\n * @param {ContentPath} contentPath\n * @returns {ContentPath[]}\n */ function resolvePathSymlinks(contentPath) {\n    let paths = [\n        contentPath\n    ];\n    try {\n        let resolvedPath = _fs.default.realpathSync(contentPath.base);\n        if (resolvedPath !== contentPath.base) {\n            paths.push({\n                ...contentPath,\n                base: resolvedPath\n            });\n        }\n    } catch  {\n    // TODO: log this?\n    }\n    return paths;\n}\nfunction resolvedChangedContent(context, candidateFiles, fileModifiedMap) {\n    let changedContent = context.tailwindConfig.content.files.filter((item)=>typeof item.raw === \"string\").map(({ raw , extension =\"html\"  })=>({\n            content: raw,\n            extension\n        }));\n    let [changedFiles, mTimesToCommit] = resolveChangedFiles(candidateFiles, fileModifiedMap);\n    for (let changedFile of changedFiles){\n        let extension = _path.default.extname(changedFile).slice(1);\n        changedContent.push({\n            file: changedFile,\n            extension\n        });\n    }\n    return [\n        changedContent,\n        mTimesToCommit\n    ];\n}\nconst LARGE_DIRECTORIES = [\n    \"node_modules\"\n];\n// Ensures that `node_modules` has to match as-is, otherwise `mynode_modules`\n// would match as well, but that is not a known large directory.\nconst LARGE_DIRECTORIES_REGEX = new RegExp(`(${LARGE_DIRECTORIES.map((dir)=>String.raw`\\b${dir}\\b`).join(\"|\")})`);\nfunction createBroadPatternCheck(paths) {\n    // Detect whether a glob pattern might be too broad. This means that it:\n    // - Includes `**`\n    // - Does not include any of the known large directories (e.g.: node_modules)\n    let maybeBroadPattern = paths.some((path)=>path.includes(\"**\") && !LARGE_DIRECTORIES_REGEX.test(path));\n    // Didn't detect any potentially broad patterns, so we can skip further\n    // checks.\n    if (!maybeBroadPattern) {\n        return ()=>{};\n    }\n    // All glob matchers\n    let matchers = [];\n    // All glob matchers that explicitly contain any of the known large\n    // directories (e.g.: node_modules).\n    let explicitMatchers = [];\n    // Create matchers for all paths\n    for (let path of paths){\n        let matcher = _micromatch.default.matcher(path);\n        if (LARGE_DIRECTORIES_REGEX.test(path)) {\n            explicitMatchers.push(matcher);\n        }\n        matchers.push(matcher);\n    }\n    // Keep track of whether we already warned about the broad pattern issue or\n    // not. The `log.warn` function already does something similar where we only\n    // output the log once. However, with this we can also skip the other checks\n    // when we already warned about the broad pattern.\n    let warned = false;\n    /**\n   * @param {string} file\n   */ return (file)=>{\n        if (warned) return; // Already warned about the broad pattern\n        if (explicitMatchers.some((matcher)=>matcher(file))) return; // Explicitly included, so we can skip further checks\n        // When a broad pattern is used, we have to double check that the file was\n        // not explicitly included in the globs.\n        let matchingGlobIndex = matchers.findIndex((matcher)=>matcher(file));\n        if (matchingGlobIndex === -1) return; // This should never happen\n        let matchingGlob = paths[matchingGlobIndex];\n        // Create relative paths to make the output a bit more readable.\n        let relativeMatchingGlob = _path.default.relative(process.cwd(), matchingGlob);\n        if (relativeMatchingGlob[0] !== \".\") relativeMatchingGlob = `./${relativeMatchingGlob}`;\n        let largeDirectory = LARGE_DIRECTORIES.find((directory)=>file.includes(directory));\n        if (largeDirectory) {\n            warned = true;\n            _log.default.warn(\"broad-content-glob-pattern\", [\n                `Your \\`content\\` configuration includes a pattern which looks like it's accidentally matching all of \\`${largeDirectory}\\` and can cause serious performance issues.`,\n                `Pattern: \\`${relativeMatchingGlob}\\``,\n                `See our documentation for recommendations:`,\n                \"https://tailwindcss.com/docs/content-configuration#pattern-recommendations\"\n            ]);\n        }\n    };\n}\n/**\n *\n * @param {ContentPath[]} candidateFiles\n * @param {Map<string, number>} fileModifiedMap\n * @returns {[Set<string>, Map<string, number>]}\n */ function resolveChangedFiles(candidateFiles, fileModifiedMap) {\n    let paths = candidateFiles.map((contentPath)=>contentPath.pattern);\n    let mTimesToCommit = new Map();\n    let checkBroadPattern = createBroadPatternCheck(paths);\n    let changedFiles = new Set();\n    _sharedState.env.DEBUG && console.time(\"Finding changed files\");\n    let files = _fastglob.default.sync(paths, {\n        absolute: true\n    });\n    for (let file of files){\n        checkBroadPattern(file);\n        let prevModified = fileModifiedMap.get(file) || -Infinity;\n        let modified = _fs.default.statSync(file).mtimeMs;\n        if (modified > prevModified) {\n            changedFiles.add(file);\n            mTimesToCommit.set(file, modified);\n        }\n    }\n    _sharedState.env.DEBUG && console.timeEnd(\"Finding changed files\");\n    return [\n        changedFiles,\n        mTimesToCommit\n    ];\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}