{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"defaultExtractor\", {\n  enumerable: true,\n  get: function () {\n    return defaultExtractor;\n  }\n});\nconst _regex = /*#__PURE__*/_interop_require_wildcard(require(\"./regex\"));\nconst _splitAtTopLevelOnly = require(\"../util/splitAtTopLevelOnly\");\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== \"function\") return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function (nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\nfunction _interop_require_wildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n  var cache = _getRequireWildcardCache(nodeInterop);\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n  for (var key in obj) {\n    if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n  newObj.default = obj;\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n  return newObj;\n}\nfunction defaultExtractor(context) {\n  let patterns = Array.from(buildRegExps(context));\n  /**\n  * @param {string} content\n  */\n  return content => {\n    /** @type {(string|string)[]} */let results = [];\n    for (let pattern of patterns) {\n      var _content_match;\n      for (let result of (_content_match = content.match(pattern)) !== null && _content_match !== void 0 ? _content_match : []) {\n        results.push(clipAtBalancedParens(result));\n      }\n    }\n    // Extract any subclasses from languages like Slim and Pug, eg:\n    // div.flex.px-5.underline\n    for (let result of results.slice()) {\n      let segments = (0, _splitAtTopLevelOnly.splitAtTopLevelOnly)(result, \".\");\n      for (let idx = 0; idx < segments.length; idx++) {\n        let segment = segments[idx];\n        if (idx >= segments.length - 1) {\n          results.push(segment);\n          continue;\n        }\n        // If the next segment is a number, discard both, for example seeing\n        // `px-1` and `5` means the real candidate was `px-1.5` which is already\n        // captured.\n        let next = Number(segments[idx + 1]);\n        if (isNaN(next)) {\n          results.push(segment);\n        } else {\n          idx++;\n        }\n      }\n    }\n    return results;\n  };\n}\nfunction* buildRegExps(context) {\n  let separator = context.tailwindConfig.separator;\n  let prefix = context.tailwindConfig.prefix !== \"\" ? _regex.optional(_regex.pattern([/-?/, _regex.escape(context.tailwindConfig.prefix)])) : \"\";\n  let utility = _regex.any([\n  // Arbitrary properties (without square brackets)\n  /\\[[^\\s:'\"`]+:[^\\s\\[\\]]+\\]/,\n  // Arbitrary properties with balanced square brackets\n  // This is a targeted fix to continue to allow theme()\n  // with square brackets to work in arbitrary properties\n  // while fixing a problem with the regex matching too much\n  /\\[[^\\s:'\"`\\]]+:[^\\s]+?\\[[^\\s]+\\][^\\s]+?\\]/,\n  // Utilities\n  _regex.pattern([\n  // Utility Name / Group Name\n  _regex.any([/-?(?:\\w+)/,\n  // This is here to make sure @container supports everything that other utilities do\n  /@(?:\\w+)/]),\n  // Normal/Arbitrary values\n  _regex.optional(_regex.any([_regex.pattern([\n  // Arbitrary values\n  _regex.any([/-(?:\\w+-)*\\['[^\\s]+'\\]/, /-(?:\\w+-)*\\[\"[^\\s]+\"\\]/, /-(?:\\w+-)*\\[`[^\\s]+`\\]/, /-(?:\\w+-)*\\[(?:[^\\s\\[\\]]+\\[[^\\s\\[\\]]+\\])*[^\\s:\\[\\]]+\\]/]),\n  // Not immediately followed by an `{[(`\n  /(?![{([]])/,\n  // optionally followed by an opacity modifier\n  /(?:\\/[^\\s'\"`\\\\><$]*)?/]), _regex.pattern([\n  // Arbitrary values\n  _regex.any([/-(?:\\w+-)*\\['[^\\s]+'\\]/, /-(?:\\w+-)*\\[\"[^\\s]+\"\\]/, /-(?:\\w+-)*\\[`[^\\s]+`\\]/, /-(?:\\w+-)*\\[(?:[^\\s\\[\\]]+\\[[^\\s\\[\\]]+\\])*[^\\s\\[\\]]+\\]/]),\n  // Not immediately followed by an `{[(`\n  /(?![{([]])/,\n  // optionally followed by an opacity modifier\n  /(?:\\/[^\\s'\"`\\\\$]*)?/]),\n  // Normal values w/o quotes — may include an opacity modifier\n  /[-\\/][^\\s'\"`\\\\$={><]*/]))])]);\n  let variantPatterns = [\n  // Without quotes\n  _regex.any([\n  // This is here to provide special support for the `@` variant\n  _regex.pattern([/@\\[[^\\s\"'`]+\\](\\/[^\\s\"'`]+)?/, separator]),\n  // With variant modifier (e.g.: group-[..]/modifier)\n  _regex.pattern([/([^\\s\"'`\\[\\\\]+-)?\\[[^\\s\"'`]+\\]\\/[\\w_-]+/, separator]), _regex.pattern([/([^\\s\"'`\\[\\\\]+-)?\\[[^\\s\"'`]+\\]/, separator]), _regex.pattern([/[^\\s\"'`\\[\\\\]+/, separator])]),\n  // With quotes allowed\n  _regex.any([\n  // With variant modifier (e.g.: group-[..]/modifier)\n  _regex.pattern([/([^\\s\"'`\\[\\\\]+-)?\\[[^\\s`]+\\]\\/[\\w_-]+/, separator]), _regex.pattern([/([^\\s\"'`\\[\\\\]+-)?\\[[^\\s`]+\\]/, separator]), _regex.pattern([/[^\\s`\\[\\\\]+/, separator])])];\n  for (const variantPattern of variantPatterns) {\n    yield _regex.pattern([\n    // Variants\n    \"((?=((\", variantPattern, \")+))\\\\2)?\",\n    // Important (optional)\n    /!?/, prefix, utility]);\n  }\n  // 5. Inner matches\n  yield /[^<>\"'`\\s.(){}[\\]#=%$][^<>\"'`\\s(){}[\\]#=%$]*[^<>\"'`\\s.(){}[\\]#=%:$]/g;\n}\n// We want to capture any \"special\" characters\n// AND the characters immediately following them (if there is one)\nlet SPECIALS = /([\\[\\]'\"`])([^\\[\\]'\"`])?/g;\nlet ALLOWED_CLASS_CHARACTERS = /[^\"'`\\s<>\\]]+/;\n/**\n * Clips a string ensuring that parentheses, quotes, etc… are balanced\n * Used for arbitrary values only\n *\n * We will go past the end of the balanced parens until we find a non-class character\n *\n * Depth matching behavior:\n * w-[calc(100%-theme('spacing[some_key][1.5]'))]']\n *   ┬    ┬          ┬┬       ┬        ┬┬   ┬┬┬┬┬┬┬\n *   1    2          3        4        34   3 210 END\n *   ╰────┴──────────┴────────┴────────┴┴───┴─┴┴┴\n *\n * @param {string} input\n */\nfunction clipAtBalancedParens(input) {\n  // We are care about this for arbitrary values\n  if (!input.includes(\"-[\")) {\n    return input;\n  }\n  let depth = 0;\n  let openStringTypes = [];\n  // Find all parens, brackets, quotes, etc\n  // Stop when we end at a balanced pair\n  // This is naive and will treat mismatched parens as balanced\n  // This shouldn't be a problem in practice though\n  let matches = input.matchAll(SPECIALS);\n  // We can't use lookbehind assertions because we have to support Safari\n  // So, instead, we've emulated it using capture groups and we'll re-work the matches to accommodate\n  matches = Array.from(matches).flatMap(match => {\n    const [, ...groups] = match;\n    return groups.map((group, idx) => Object.assign([], match, {\n      index: match.index + idx,\n      0: group\n    }));\n  });\n  for (let match of matches) {\n    let char = match[0];\n    let inStringType = openStringTypes[openStringTypes.length - 1];\n    if (char === inStringType) {\n      openStringTypes.pop();\n    } else if (char === \"'\" || char === '\"' || char === \"`\") {\n      openStringTypes.push(char);\n    }\n    if (inStringType) {\n      continue;\n    } else if (char === \"[\") {\n      depth++;\n      continue;\n    } else if (char === \"]\") {\n      depth--;\n      continue;\n    }\n    // We've gone one character past the point where we should stop\n    // This means that there was an extra closing `]`\n    // We'll clip to just before it\n    if (depth < 0) {\n      return input.substring(0, match.index - 1);\n    }\n    // We've finished balancing the brackets but there still may be characters that can be included\n    // For example in the class `text-[#336699]/[.35]`\n    // The depth goes to `0` at the closing `]` but goes up again at the `[`\n    // If we're at zero and encounter a non-class character then we clip the class there\n    if (depth === 0 && !ALLOWED_CLASS_CHARACTERS.test(char)) {\n      return input.substring(0, match.index);\n    }\n  }\n  return input;\n} // Regular utilities\n// {{modifier}:}*{namespace}{-{suffix}}*{/{opacityModifier}}?\n// Arbitrary values\n// {{modifier}:}*{namespace}-[{arbitraryValue}]{/{opacityModifier}}?\n// arbitraryValue: no whitespace, balanced quotes unless within quotes, balanced brackets unless within quotes\n// Arbitrary properties\n// {{modifier}:}*[{validCssPropertyName}:{arbitraryValue}]","map":{"version":3,"names":["Object","defineProperty","exports","value","enumerable","get","defaultExtractor","_regex","_interop_require_wildcard","require","_splitAtTopLevelOnly","_getRequireWildcardCache","nodeInterop","WeakMap","cacheBabelInterop","cacheNodeInterop","obj","__esModule","default","cache","has","newObj","hasPropertyDescriptor","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","context","patterns","Array","from","buildRegExps","content","results","pattern","_content_match","result","match","push","clipAtBalancedParens","slice","segments","splitAtTopLevelOnly","idx","length","segment","next","Number","isNaN","separator","tailwindConfig","prefix","optional","escape","utility","any","variantPatterns","variantPattern","SPECIALS","ALLOWED_CLASS_CHARACTERS","input","includes","depth","openStringTypes","matches","matchAll","flatMap","groups","map","group","assign","index","char","inStringType","pop","substring","test"],"sources":["/Users/zeynepbas/Desktop/stackowerflow/node_modules/tailwindcss/lib/lib/defaultExtractor.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"defaultExtractor\", {\n    enumerable: true,\n    get: function() {\n        return defaultExtractor;\n    }\n});\nconst _regex = /*#__PURE__*/ _interop_require_wildcard(require(\"./regex\"));\nconst _splitAtTopLevelOnly = require(\"../util/splitAtTopLevelOnly\");\nfunction _getRequireWildcardCache(nodeInterop) {\n    if (typeof WeakMap !== \"function\") return null;\n    var cacheBabelInterop = new WeakMap();\n    var cacheNodeInterop = new WeakMap();\n    return (_getRequireWildcardCache = function(nodeInterop) {\n        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n    })(nodeInterop);\n}\nfunction _interop_require_wildcard(obj, nodeInterop) {\n    if (!nodeInterop && obj && obj.__esModule) {\n        return obj;\n    }\n    if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n        return {\n            default: obj\n        };\n    }\n    var cache = _getRequireWildcardCache(nodeInterop);\n    if (cache && cache.has(obj)) {\n        return cache.get(obj);\n    }\n    var newObj = {};\n    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for(var key in obj){\n        if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n            if (desc && (desc.get || desc.set)) {\n                Object.defineProperty(newObj, key, desc);\n            } else {\n                newObj[key] = obj[key];\n            }\n        }\n    }\n    newObj.default = obj;\n    if (cache) {\n        cache.set(obj, newObj);\n    }\n    return newObj;\n}\nfunction defaultExtractor(context) {\n    let patterns = Array.from(buildRegExps(context));\n    /**\n   * @param {string} content\n   */ return (content)=>{\n        /** @type {(string|string)[]} */ let results = [];\n        for (let pattern of patterns){\n            var _content_match;\n            for (let result of (_content_match = content.match(pattern)) !== null && _content_match !== void 0 ? _content_match : []){\n                results.push(clipAtBalancedParens(result));\n            }\n        }\n        // Extract any subclasses from languages like Slim and Pug, eg:\n        // div.flex.px-5.underline\n        for (let result of results.slice()){\n            let segments = (0, _splitAtTopLevelOnly.splitAtTopLevelOnly)(result, \".\");\n            for(let idx = 0; idx < segments.length; idx++){\n                let segment = segments[idx];\n                if (idx >= segments.length - 1) {\n                    results.push(segment);\n                    continue;\n                }\n                // If the next segment is a number, discard both, for example seeing\n                // `px-1` and `5` means the real candidate was `px-1.5` which is already\n                // captured.\n                let next = Number(segments[idx + 1]);\n                if (isNaN(next)) {\n                    results.push(segment);\n                } else {\n                    idx++;\n                }\n            }\n        }\n        return results;\n    };\n}\nfunction* buildRegExps(context) {\n    let separator = context.tailwindConfig.separator;\n    let prefix = context.tailwindConfig.prefix !== \"\" ? _regex.optional(_regex.pattern([\n        /-?/,\n        _regex.escape(context.tailwindConfig.prefix)\n    ])) : \"\";\n    let utility = _regex.any([\n        // Arbitrary properties (without square brackets)\n        /\\[[^\\s:'\"`]+:[^\\s\\[\\]]+\\]/,\n        // Arbitrary properties with balanced square brackets\n        // This is a targeted fix to continue to allow theme()\n        // with square brackets to work in arbitrary properties\n        // while fixing a problem with the regex matching too much\n        /\\[[^\\s:'\"`\\]]+:[^\\s]+?\\[[^\\s]+\\][^\\s]+?\\]/,\n        // Utilities\n        _regex.pattern([\n            // Utility Name / Group Name\n            _regex.any([\n                /-?(?:\\w+)/,\n                // This is here to make sure @container supports everything that other utilities do\n                /@(?:\\w+)/\n            ]),\n            // Normal/Arbitrary values\n            _regex.optional(_regex.any([\n                _regex.pattern([\n                    // Arbitrary values\n                    _regex.any([\n                        /-(?:\\w+-)*\\['[^\\s]+'\\]/,\n                        /-(?:\\w+-)*\\[\"[^\\s]+\"\\]/,\n                        /-(?:\\w+-)*\\[`[^\\s]+`\\]/,\n                        /-(?:\\w+-)*\\[(?:[^\\s\\[\\]]+\\[[^\\s\\[\\]]+\\])*[^\\s:\\[\\]]+\\]/\n                    ]),\n                    // Not immediately followed by an `{[(`\n                    /(?![{([]])/,\n                    // optionally followed by an opacity modifier\n                    /(?:\\/[^\\s'\"`\\\\><$]*)?/\n                ]),\n                _regex.pattern([\n                    // Arbitrary values\n                    _regex.any([\n                        /-(?:\\w+-)*\\['[^\\s]+'\\]/,\n                        /-(?:\\w+-)*\\[\"[^\\s]+\"\\]/,\n                        /-(?:\\w+-)*\\[`[^\\s]+`\\]/,\n                        /-(?:\\w+-)*\\[(?:[^\\s\\[\\]]+\\[[^\\s\\[\\]]+\\])*[^\\s\\[\\]]+\\]/\n                    ]),\n                    // Not immediately followed by an `{[(`\n                    /(?![{([]])/,\n                    // optionally followed by an opacity modifier\n                    /(?:\\/[^\\s'\"`\\\\$]*)?/\n                ]),\n                // Normal values w/o quotes — may include an opacity modifier\n                /[-\\/][^\\s'\"`\\\\$={><]*/\n            ]))\n        ])\n    ]);\n    let variantPatterns = [\n        // Without quotes\n        _regex.any([\n            // This is here to provide special support for the `@` variant\n            _regex.pattern([\n                /@\\[[^\\s\"'`]+\\](\\/[^\\s\"'`]+)?/,\n                separator\n            ]),\n            // With variant modifier (e.g.: group-[..]/modifier)\n            _regex.pattern([\n                /([^\\s\"'`\\[\\\\]+-)?\\[[^\\s\"'`]+\\]\\/[\\w_-]+/,\n                separator\n            ]),\n            _regex.pattern([\n                /([^\\s\"'`\\[\\\\]+-)?\\[[^\\s\"'`]+\\]/,\n                separator\n            ]),\n            _regex.pattern([\n                /[^\\s\"'`\\[\\\\]+/,\n                separator\n            ])\n        ]),\n        // With quotes allowed\n        _regex.any([\n            // With variant modifier (e.g.: group-[..]/modifier)\n            _regex.pattern([\n                /([^\\s\"'`\\[\\\\]+-)?\\[[^\\s`]+\\]\\/[\\w_-]+/,\n                separator\n            ]),\n            _regex.pattern([\n                /([^\\s\"'`\\[\\\\]+-)?\\[[^\\s`]+\\]/,\n                separator\n            ]),\n            _regex.pattern([\n                /[^\\s`\\[\\\\]+/,\n                separator\n            ])\n        ])\n    ];\n    for (const variantPattern of variantPatterns){\n        yield _regex.pattern([\n            // Variants\n            \"((?=((\",\n            variantPattern,\n            \")+))\\\\2)?\",\n            // Important (optional)\n            /!?/,\n            prefix,\n            utility\n        ]);\n    }\n    // 5. Inner matches\n    yield /[^<>\"'`\\s.(){}[\\]#=%$][^<>\"'`\\s(){}[\\]#=%$]*[^<>\"'`\\s.(){}[\\]#=%:$]/g;\n}\n// We want to capture any \"special\" characters\n// AND the characters immediately following them (if there is one)\nlet SPECIALS = /([\\[\\]'\"`])([^\\[\\]'\"`])?/g;\nlet ALLOWED_CLASS_CHARACTERS = /[^\"'`\\s<>\\]]+/;\n/**\n * Clips a string ensuring that parentheses, quotes, etc… are balanced\n * Used for arbitrary values only\n *\n * We will go past the end of the balanced parens until we find a non-class character\n *\n * Depth matching behavior:\n * w-[calc(100%-theme('spacing[some_key][1.5]'))]']\n *   ┬    ┬          ┬┬       ┬        ┬┬   ┬┬┬┬┬┬┬\n *   1    2          3        4        34   3 210 END\n *   ╰────┴──────────┴────────┴────────┴┴───┴─┴┴┴\n *\n * @param {string} input\n */ function clipAtBalancedParens(input) {\n    // We are care about this for arbitrary values\n    if (!input.includes(\"-[\")) {\n        return input;\n    }\n    let depth = 0;\n    let openStringTypes = [];\n    // Find all parens, brackets, quotes, etc\n    // Stop when we end at a balanced pair\n    // This is naive and will treat mismatched parens as balanced\n    // This shouldn't be a problem in practice though\n    let matches = input.matchAll(SPECIALS);\n    // We can't use lookbehind assertions because we have to support Safari\n    // So, instead, we've emulated it using capture groups and we'll re-work the matches to accommodate\n    matches = Array.from(matches).flatMap((match)=>{\n        const [, ...groups] = match;\n        return groups.map((group, idx)=>Object.assign([], match, {\n                index: match.index + idx,\n                0: group\n            }));\n    });\n    for (let match of matches){\n        let char = match[0];\n        let inStringType = openStringTypes[openStringTypes.length - 1];\n        if (char === inStringType) {\n            openStringTypes.pop();\n        } else if (char === \"'\" || char === '\"' || char === \"`\") {\n            openStringTypes.push(char);\n        }\n        if (inStringType) {\n            continue;\n        } else if (char === \"[\") {\n            depth++;\n            continue;\n        } else if (char === \"]\") {\n            depth--;\n            continue;\n        }\n        // We've gone one character past the point where we should stop\n        // This means that there was an extra closing `]`\n        // We'll clip to just before it\n        if (depth < 0) {\n            return input.substring(0, match.index - 1);\n        }\n        // We've finished balancing the brackets but there still may be characters that can be included\n        // For example in the class `text-[#336699]/[.35]`\n        // The depth goes to `0` at the closing `]` but goes up again at the `[`\n        // If we're at zero and encounter a non-class character then we clip the class there\n        if (depth === 0 && !ALLOWED_CLASS_CHARACTERS.test(char)) {\n            return input.substring(0, match.index);\n        }\n    }\n    return input;\n} // Regular utilities\n // {{modifier}:}*{namespace}{-{suffix}}*{/{opacityModifier}}?\n // Arbitrary values\n // {{modifier}:}*{namespace}-[{arbitraryValue}]{/{opacityModifier}}?\n // arbitraryValue: no whitespace, balanced quotes unless within quotes, balanced brackets unless within quotes\n // Arbitrary properties\n // {{modifier}:}*[{validCssPropertyName}:{arbitraryValue}]\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}