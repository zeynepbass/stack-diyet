{"ast":null,"code":"'use strict';\n\nlet {\n  existsSync,\n  readFileSync\n} = require('fs');\nlet {\n  dirname,\n  join\n} = require('path');\nlet {\n  SourceMapConsumer,\n  SourceMapGenerator\n} = require('source-map-js');\nfunction fromBase64(str) {\n  if (Buffer) {\n    return Buffer.from(str, 'base64').toString();\n  } else {\n    /* c8 ignore next 2 */\n    return window.atob(str);\n  }\n}\nclass PreviousMap {\n  constructor(css, opts) {\n    if (opts.map === false) return;\n    this.loadAnnotation(css);\n    this.inline = this.startWith(this.annotation, 'data:');\n    let prev = opts.map ? opts.map.prev : undefined;\n    let text = this.loadMap(opts.from, prev);\n    if (!this.mapFile && opts.from) {\n      this.mapFile = opts.from;\n    }\n    if (this.mapFile) this.root = dirname(this.mapFile);\n    if (text) this.text = text;\n  }\n  consumer() {\n    if (!this.consumerCache) {\n      this.consumerCache = new SourceMapConsumer(this.text);\n    }\n    return this.consumerCache;\n  }\n  decodeInline(text) {\n    let baseCharsetUri = /^data:application\\/json;charset=utf-?8;base64,/;\n    let baseUri = /^data:application\\/json;base64,/;\n    let charsetUri = /^data:application\\/json;charset=utf-?8,/;\n    let uri = /^data:application\\/json,/;\n    let uriMatch = text.match(charsetUri) || text.match(uri);\n    if (uriMatch) {\n      return decodeURIComponent(text.substr(uriMatch[0].length));\n    }\n    let baseUriMatch = text.match(baseCharsetUri) || text.match(baseUri);\n    if (baseUriMatch) {\n      return fromBase64(text.substr(baseUriMatch[0].length));\n    }\n    let encoding = text.match(/data:application\\/json;([^,]+),/)[1];\n    throw new Error('Unsupported source map encoding ' + encoding);\n  }\n  getAnnotationURL(sourceMapString) {\n    return sourceMapString.replace(/^\\/\\*\\s*# sourceMappingURL=/, '').trim();\n  }\n  isMap(map) {\n    if (typeof map !== 'object') return false;\n    return typeof map.mappings === 'string' || typeof map._mappings === 'string' || Array.isArray(map.sections);\n  }\n  loadAnnotation(css) {\n    let comments = css.match(/\\/\\*\\s*# sourceMappingURL=/g);\n    if (!comments) return;\n\n    // sourceMappingURLs from comments, strings, etc.\n    let start = css.lastIndexOf(comments.pop());\n    let end = css.indexOf('*/', start);\n    if (start > -1 && end > -1) {\n      // Locate the last sourceMappingURL to avoid pickin\n      this.annotation = this.getAnnotationURL(css.substring(start, end));\n    }\n  }\n  loadFile(path) {\n    this.root = dirname(path);\n    if (existsSync(path)) {\n      this.mapFile = path;\n      return readFileSync(path, 'utf-8').toString().trim();\n    }\n  }\n  loadMap(file, prev) {\n    if (prev === false) return false;\n    if (prev) {\n      if (typeof prev === 'string') {\n        return prev;\n      } else if (typeof prev === 'function') {\n        let prevPath = prev(file);\n        if (prevPath) {\n          let map = this.loadFile(prevPath);\n          if (!map) {\n            throw new Error('Unable to load previous source map: ' + prevPath.toString());\n          }\n          return map;\n        }\n      } else if (prev instanceof SourceMapConsumer) {\n        return SourceMapGenerator.fromSourceMap(prev).toString();\n      } else if (prev instanceof SourceMapGenerator) {\n        return prev.toString();\n      } else if (this.isMap(prev)) {\n        return JSON.stringify(prev);\n      } else {\n        throw new Error('Unsupported previous source map format: ' + prev.toString());\n      }\n    } else if (this.inline) {\n      return this.decodeInline(this.annotation);\n    } else if (this.annotation) {\n      let map = this.annotation;\n      if (file) map = join(dirname(file), map);\n      return this.loadFile(map);\n    }\n  }\n  startWith(string, start) {\n    if (!string) return false;\n    return string.substr(0, start.length) === start;\n  }\n  withContent() {\n    return !!(this.consumer().sourcesContent && this.consumer().sourcesContent.length > 0);\n  }\n}\nmodule.exports = PreviousMap;\nPreviousMap.default = PreviousMap;","map":{"version":3,"names":["existsSync","readFileSync","require","dirname","join","SourceMapConsumer","SourceMapGenerator","fromBase64","str","Buffer","from","toString","window","atob","PreviousMap","constructor","css","opts","map","loadAnnotation","inline","startWith","annotation","prev","undefined","text","loadMap","mapFile","root","consumer","consumerCache","decodeInline","baseCharsetUri","baseUri","charsetUri","uri","uriMatch","match","decodeURIComponent","substr","length","baseUriMatch","encoding","Error","getAnnotationURL","sourceMapString","replace","trim","isMap","mappings","_mappings","Array","isArray","sections","comments","start","lastIndexOf","pop","end","indexOf","substring","loadFile","path","file","prevPath","fromSourceMap","JSON","stringify","string","withContent","sourcesContent","module","exports","default"],"sources":["/Users/zeynepbas/Desktop/stackowerflow/node_modules/postcss/lib/previous-map.js"],"sourcesContent":["'use strict'\n\nlet { existsSync, readFileSync } = require('fs')\nlet { dirname, join } = require('path')\nlet { SourceMapConsumer, SourceMapGenerator } = require('source-map-js')\n\nfunction fromBase64(str) {\n  if (Buffer) {\n    return Buffer.from(str, 'base64').toString()\n  } else {\n    /* c8 ignore next 2 */\n    return window.atob(str)\n  }\n}\n\nclass PreviousMap {\n  constructor(css, opts) {\n    if (opts.map === false) return\n    this.loadAnnotation(css)\n    this.inline = this.startWith(this.annotation, 'data:')\n\n    let prev = opts.map ? opts.map.prev : undefined\n    let text = this.loadMap(opts.from, prev)\n    if (!this.mapFile && opts.from) {\n      this.mapFile = opts.from\n    }\n    if (this.mapFile) this.root = dirname(this.mapFile)\n    if (text) this.text = text\n  }\n\n  consumer() {\n    if (!this.consumerCache) {\n      this.consumerCache = new SourceMapConsumer(this.text)\n    }\n    return this.consumerCache\n  }\n\n  decodeInline(text) {\n    let baseCharsetUri = /^data:application\\/json;charset=utf-?8;base64,/\n    let baseUri = /^data:application\\/json;base64,/\n    let charsetUri = /^data:application\\/json;charset=utf-?8,/\n    let uri = /^data:application\\/json,/\n\n    let uriMatch = text.match(charsetUri) || text.match(uri)\n    if (uriMatch) {\n      return decodeURIComponent(text.substr(uriMatch[0].length))\n    }\n\n    let baseUriMatch = text.match(baseCharsetUri) || text.match(baseUri)\n    if (baseUriMatch) {\n      return fromBase64(text.substr(baseUriMatch[0].length))\n    }\n\n    let encoding = text.match(/data:application\\/json;([^,]+),/)[1]\n    throw new Error('Unsupported source map encoding ' + encoding)\n  }\n\n  getAnnotationURL(sourceMapString) {\n    return sourceMapString.replace(/^\\/\\*\\s*# sourceMappingURL=/, '').trim()\n  }\n\n  isMap(map) {\n    if (typeof map !== 'object') return false\n    return (\n      typeof map.mappings === 'string' ||\n      typeof map._mappings === 'string' ||\n      Array.isArray(map.sections)\n    )\n  }\n\n  loadAnnotation(css) {\n    let comments = css.match(/\\/\\*\\s*# sourceMappingURL=/g)\n    if (!comments) return\n\n    // sourceMappingURLs from comments, strings, etc.\n    let start = css.lastIndexOf(comments.pop())\n    let end = css.indexOf('*/', start)\n\n    if (start > -1 && end > -1) {\n      // Locate the last sourceMappingURL to avoid pickin\n      this.annotation = this.getAnnotationURL(css.substring(start, end))\n    }\n  }\n\n  loadFile(path) {\n    this.root = dirname(path)\n    if (existsSync(path)) {\n      this.mapFile = path\n      return readFileSync(path, 'utf-8').toString().trim()\n    }\n  }\n\n  loadMap(file, prev) {\n    if (prev === false) return false\n\n    if (prev) {\n      if (typeof prev === 'string') {\n        return prev\n      } else if (typeof prev === 'function') {\n        let prevPath = prev(file)\n        if (prevPath) {\n          let map = this.loadFile(prevPath)\n          if (!map) {\n            throw new Error(\n              'Unable to load previous source map: ' + prevPath.toString()\n            )\n          }\n          return map\n        }\n      } else if (prev instanceof SourceMapConsumer) {\n        return SourceMapGenerator.fromSourceMap(prev).toString()\n      } else if (prev instanceof SourceMapGenerator) {\n        return prev.toString()\n      } else if (this.isMap(prev)) {\n        return JSON.stringify(prev)\n      } else {\n        throw new Error(\n          'Unsupported previous source map format: ' + prev.toString()\n        )\n      }\n    } else if (this.inline) {\n      return this.decodeInline(this.annotation)\n    } else if (this.annotation) {\n      let map = this.annotation\n      if (file) map = join(dirname(file), map)\n      return this.loadFile(map)\n    }\n  }\n\n  startWith(string, start) {\n    if (!string) return false\n    return string.substr(0, start.length) === start\n  }\n\n  withContent() {\n    return !!(\n      this.consumer().sourcesContent &&\n      this.consumer().sourcesContent.length > 0\n    )\n  }\n}\n\nmodule.exports = PreviousMap\nPreviousMap.default = PreviousMap\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}