{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nfunction _export(target, all) {\n  for (var name in all) Object.defineProperty(target, name, {\n    enumerable: true,\n    get: all[name]\n  });\n}\n_export(exports, {\n  updateAllClasses: function () {\n    return updateAllClasses;\n  },\n  asValue: function () {\n    return asValue;\n  },\n  parseColorFormat: function () {\n    return parseColorFormat;\n  },\n  asColor: function () {\n    return asColor;\n  },\n  asLookupValue: function () {\n    return asLookupValue;\n  },\n  typeMap: function () {\n    return typeMap;\n  },\n  coerceValue: function () {\n    return coerceValue;\n  },\n  getMatchingTypes: function () {\n    return getMatchingTypes;\n  }\n});\nconst _escapeCommas = /*#__PURE__*/_interop_require_default(require(\"./escapeCommas\"));\nconst _withAlphaVariable = require(\"./withAlphaVariable\");\nconst _dataTypes = require(\"./dataTypes\");\nconst _negateValue = /*#__PURE__*/_interop_require_default(require(\"./negateValue\"));\nconst _validateFormalSyntax = require(\"./validateFormalSyntax\");\nconst _featureFlags = require(\"../featureFlags.js\");\nfunction _interop_require_default(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction updateAllClasses(selectors, updateClass) {\n  selectors.walkClasses(sel => {\n    sel.value = updateClass(sel.value);\n    if (sel.raws && sel.raws.value) {\n      sel.raws.value = (0, _escapeCommas.default)(sel.raws.value);\n    }\n  });\n}\nfunction resolveArbitraryValue(modifier, validate) {\n  if (!isArbitraryValue(modifier)) {\n    return undefined;\n  }\n  let value = modifier.slice(1, -1);\n  if (!validate(value)) {\n    return undefined;\n  }\n  return (0, _dataTypes.normalize)(value);\n}\nfunction asNegativeValue(modifier, lookup = {}, validate) {\n  let positiveValue = lookup[modifier];\n  if (positiveValue !== undefined) {\n    return (0, _negateValue.default)(positiveValue);\n  }\n  if (isArbitraryValue(modifier)) {\n    let resolved = resolveArbitraryValue(modifier, validate);\n    if (resolved === undefined) {\n      return undefined;\n    }\n    return (0, _negateValue.default)(resolved);\n  }\n}\nfunction asValue(modifier, options = {}, {\n  validate = () => true\n} = {}) {\n  var _options_values;\n  let value = (_options_values = options.values) === null || _options_values === void 0 ? void 0 : _options_values[modifier];\n  if (value !== undefined) {\n    return value;\n  }\n  if (options.supportsNegativeValues && modifier.startsWith(\"-\")) {\n    return asNegativeValue(modifier.slice(1), options.values, validate);\n  }\n  return resolveArbitraryValue(modifier, validate);\n}\nfunction isArbitraryValue(input) {\n  return input.startsWith(\"[\") && input.endsWith(\"]\");\n}\nfunction splitUtilityModifier(modifier) {\n  let slashIdx = modifier.lastIndexOf(\"/\");\n  // If the `/` is inside an arbitrary, we want to find the previous one if any\n  // This logic probably isn't perfect but it should work for most cases\n  let arbitraryStartIdx = modifier.lastIndexOf(\"[\", slashIdx);\n  let arbitraryEndIdx = modifier.indexOf(\"]\", slashIdx);\n  let isNextToArbitrary = modifier[slashIdx - 1] === \"]\" || modifier[slashIdx + 1] === \"[\";\n  // Backtrack to the previous `/` if the one we found was inside an arbitrary\n  if (!isNextToArbitrary) {\n    if (arbitraryStartIdx !== -1 && arbitraryEndIdx !== -1) {\n      if (arbitraryStartIdx < slashIdx && slashIdx < arbitraryEndIdx) {\n        slashIdx = modifier.lastIndexOf(\"/\", arbitraryStartIdx);\n      }\n    }\n  }\n  if (slashIdx === -1 || slashIdx === modifier.length - 1) {\n    return [modifier, undefined];\n  }\n  let arbitrary = isArbitraryValue(modifier);\n  // The modifier could be of the form `[foo]/[bar]`\n  // We want to handle this case properly\n  // without affecting `[foo/bar]`\n  if (arbitrary && !modifier.includes(\"]/[\")) {\n    return [modifier, undefined];\n  }\n  return [modifier.slice(0, slashIdx), modifier.slice(slashIdx + 1)];\n}\nfunction parseColorFormat(value) {\n  if (typeof value === \"string\" && value.includes(\"<alpha-value>\")) {\n    let oldValue = value;\n    return ({\n      opacityValue = 1\n    }) => oldValue.replace(/<alpha-value>/g, opacityValue);\n  }\n  return value;\n}\nfunction unwrapArbitraryModifier(modifier) {\n  return (0, _dataTypes.normalize)(modifier.slice(1, -1));\n}\nfunction asColor(modifier, options = {}, {\n  tailwindConfig = {}\n} = {}) {\n  var _options_values;\n  if (((_options_values = options.values) === null || _options_values === void 0 ? void 0 : _options_values[modifier]) !== undefined) {\n    var _options_values1;\n    return parseColorFormat((_options_values1 = options.values) === null || _options_values1 === void 0 ? void 0 : _options_values1[modifier]);\n  }\n  // TODO: Hoist this up to getMatchingTypes or something\n  // We do this here because we need the alpha value (if any)\n  let [color, alpha] = splitUtilityModifier(modifier);\n  if (alpha !== undefined) {\n    var _options_values2, _tailwindConfig_theme, _tailwindConfig_theme_opacity;\n    var _options_values_color;\n    let normalizedColor = (_options_values_color = (_options_values2 = options.values) === null || _options_values2 === void 0 ? void 0 : _options_values2[color]) !== null && _options_values_color !== void 0 ? _options_values_color : isArbitraryValue(color) ? color.slice(1, -1) : undefined;\n    if (normalizedColor === undefined) {\n      return undefined;\n    }\n    normalizedColor = parseColorFormat(normalizedColor);\n    if (isArbitraryValue(alpha)) {\n      return (0, _withAlphaVariable.withAlphaValue)(normalizedColor, unwrapArbitraryModifier(alpha));\n    }\n    if (((_tailwindConfig_theme = tailwindConfig.theme) === null || _tailwindConfig_theme === void 0 ? void 0 : (_tailwindConfig_theme_opacity = _tailwindConfig_theme.opacity) === null || _tailwindConfig_theme_opacity === void 0 ? void 0 : _tailwindConfig_theme_opacity[alpha]) === undefined) {\n      return undefined;\n    }\n    return (0, _withAlphaVariable.withAlphaValue)(normalizedColor, tailwindConfig.theme.opacity[alpha]);\n  }\n  return asValue(modifier, options, {\n    validate: _dataTypes.color\n  });\n}\nfunction asLookupValue(modifier, options = {}) {\n  var _options_values;\n  return (_options_values = options.values) === null || _options_values === void 0 ? void 0 : _options_values[modifier];\n}\nfunction guess(validate) {\n  return (modifier, options) => {\n    return asValue(modifier, options, {\n      validate\n    });\n  };\n}\nlet typeMap = {\n  any: asValue,\n  color: asColor,\n  url: guess(_dataTypes.url),\n  image: guess(_dataTypes.image),\n  length: guess(_dataTypes.length),\n  percentage: guess(_dataTypes.percentage),\n  position: guess(_dataTypes.position),\n  lookup: asLookupValue,\n  \"generic-name\": guess(_dataTypes.genericName),\n  \"family-name\": guess(_dataTypes.familyName),\n  number: guess(_dataTypes.number),\n  \"line-width\": guess(_dataTypes.lineWidth),\n  \"absolute-size\": guess(_dataTypes.absoluteSize),\n  \"relative-size\": guess(_dataTypes.relativeSize),\n  shadow: guess(_dataTypes.shadow),\n  size: guess(_validateFormalSyntax.backgroundSize)\n};\nlet supportedTypes = Object.keys(typeMap);\nfunction splitAtFirst(input, delim) {\n  let idx = input.indexOf(delim);\n  if (idx === -1) return [undefined, input];\n  return [input.slice(0, idx), input.slice(idx + 1)];\n}\nfunction coerceValue(types, modifier, options, tailwindConfig) {\n  if (options.values && modifier in options.values) {\n    for (let {\n      type\n    } of types !== null && types !== void 0 ? types : []) {\n      let result = typeMap[type](modifier, options, {\n        tailwindConfig\n      });\n      if (result === undefined) {\n        continue;\n      }\n      return [result, type, null];\n    }\n  }\n  if (isArbitraryValue(modifier)) {\n    let arbitraryValue = modifier.slice(1, -1);\n    let [explicitType, value] = splitAtFirst(arbitraryValue, \":\");\n    // It could be that this resolves to `url(https` which is not a valid\n    // identifier. We currently only support \"simple\" words with dashes or\n    // underscores. E.g.: family-name\n    if (!/^[\\w-_]+$/g.test(explicitType)) {\n      value = arbitraryValue;\n    } else if (explicitType !== undefined && !supportedTypes.includes(explicitType)) {\n      return [];\n    }\n    if (value.length > 0 && supportedTypes.includes(explicitType)) {\n      return [asValue(`[${value}]`, options), explicitType, null];\n    }\n  }\n  let matches = getMatchingTypes(types, modifier, options, tailwindConfig);\n  // Find first matching type\n  for (let match of matches) {\n    return match;\n  }\n  return [];\n}\nfunction* getMatchingTypes(types, rawModifier, options, tailwindConfig) {\n  let modifiersEnabled = (0, _featureFlags.flagEnabled)(tailwindConfig, \"generalizedModifiers\");\n  let [modifier, utilityModifier] = splitUtilityModifier(rawModifier);\n  let canUseUtilityModifier = modifiersEnabled && options.modifiers != null && (options.modifiers === \"any\" || typeof options.modifiers === \"object\" && (utilityModifier && isArbitraryValue(utilityModifier) || utilityModifier in options.modifiers));\n  if (!canUseUtilityModifier) {\n    modifier = rawModifier;\n    utilityModifier = undefined;\n  }\n  if (utilityModifier !== undefined && modifier === \"\") {\n    modifier = \"DEFAULT\";\n  }\n  // Check the full value first\n  // TODO: Move to asValue… somehow\n  if (utilityModifier !== undefined) {\n    if (typeof options.modifiers === \"object\") {\n      var _options_modifiers;\n      var _options_modifiers_utilityModifier;\n      let configValue = (_options_modifiers_utilityModifier = (_options_modifiers = options.modifiers) === null || _options_modifiers === void 0 ? void 0 : _options_modifiers[utilityModifier]) !== null && _options_modifiers_utilityModifier !== void 0 ? _options_modifiers_utilityModifier : null;\n      if (configValue !== null) {\n        utilityModifier = configValue;\n      } else if (isArbitraryValue(utilityModifier)) {\n        utilityModifier = unwrapArbitraryModifier(utilityModifier);\n      }\n    }\n  }\n  for (let {\n    type\n  } of types !== null && types !== void 0 ? types : []) {\n    let result = typeMap[type](modifier, options, {\n      tailwindConfig\n    });\n    if (result === undefined) {\n      continue;\n    }\n    yield [result, type, utilityModifier !== null && utilityModifier !== void 0 ? utilityModifier : null];\n  }\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","_export","target","all","name","enumerable","get","updateAllClasses","asValue","parseColorFormat","asColor","asLookupValue","typeMap","coerceValue","getMatchingTypes","_escapeCommas","_interop_require_default","require","_withAlphaVariable","_dataTypes","_negateValue","_validateFormalSyntax","_featureFlags","obj","__esModule","default","selectors","updateClass","walkClasses","sel","raws","resolveArbitraryValue","modifier","validate","isArbitraryValue","undefined","slice","normalize","asNegativeValue","lookup","positiveValue","resolved","options","_options_values","values","supportsNegativeValues","startsWith","input","endsWith","splitUtilityModifier","slashIdx","lastIndexOf","arbitraryStartIdx","arbitraryEndIdx","indexOf","isNextToArbitrary","length","arbitrary","includes","oldValue","opacityValue","replace","unwrapArbitraryModifier","tailwindConfig","_options_values1","color","alpha","_options_values2","_tailwindConfig_theme","_tailwindConfig_theme_opacity","_options_values_color","normalizedColor","withAlphaValue","theme","opacity","guess","any","url","image","percentage","position","genericName","familyName","number","lineWidth","absoluteSize","relativeSize","shadow","size","backgroundSize","supportedTypes","keys","splitAtFirst","delim","idx","types","type","result","arbitraryValue","explicitType","test","matches","match","rawModifier","modifiersEnabled","flagEnabled","utilityModifier","canUseUtilityModifier","modifiers","_options_modifiers","_options_modifiers_utilityModifier","configValue"],"sources":["/Users/zeynepbas/Desktop/stackowerflow/node_modules/tailwindcss/lib/util/pluginUtils.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    updateAllClasses: function() {\n        return updateAllClasses;\n    },\n    asValue: function() {\n        return asValue;\n    },\n    parseColorFormat: function() {\n        return parseColorFormat;\n    },\n    asColor: function() {\n        return asColor;\n    },\n    asLookupValue: function() {\n        return asLookupValue;\n    },\n    typeMap: function() {\n        return typeMap;\n    },\n    coerceValue: function() {\n        return coerceValue;\n    },\n    getMatchingTypes: function() {\n        return getMatchingTypes;\n    }\n});\nconst _escapeCommas = /*#__PURE__*/ _interop_require_default(require(\"./escapeCommas\"));\nconst _withAlphaVariable = require(\"./withAlphaVariable\");\nconst _dataTypes = require(\"./dataTypes\");\nconst _negateValue = /*#__PURE__*/ _interop_require_default(require(\"./negateValue\"));\nconst _validateFormalSyntax = require(\"./validateFormalSyntax\");\nconst _featureFlags = require(\"../featureFlags.js\");\nfunction _interop_require_default(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nfunction updateAllClasses(selectors, updateClass) {\n    selectors.walkClasses((sel)=>{\n        sel.value = updateClass(sel.value);\n        if (sel.raws && sel.raws.value) {\n            sel.raws.value = (0, _escapeCommas.default)(sel.raws.value);\n        }\n    });\n}\nfunction resolveArbitraryValue(modifier, validate) {\n    if (!isArbitraryValue(modifier)) {\n        return undefined;\n    }\n    let value = modifier.slice(1, -1);\n    if (!validate(value)) {\n        return undefined;\n    }\n    return (0, _dataTypes.normalize)(value);\n}\nfunction asNegativeValue(modifier, lookup = {}, validate) {\n    let positiveValue = lookup[modifier];\n    if (positiveValue !== undefined) {\n        return (0, _negateValue.default)(positiveValue);\n    }\n    if (isArbitraryValue(modifier)) {\n        let resolved = resolveArbitraryValue(modifier, validate);\n        if (resolved === undefined) {\n            return undefined;\n        }\n        return (0, _negateValue.default)(resolved);\n    }\n}\nfunction asValue(modifier, options = {}, { validate =()=>true  } = {}) {\n    var _options_values;\n    let value = (_options_values = options.values) === null || _options_values === void 0 ? void 0 : _options_values[modifier];\n    if (value !== undefined) {\n        return value;\n    }\n    if (options.supportsNegativeValues && modifier.startsWith(\"-\")) {\n        return asNegativeValue(modifier.slice(1), options.values, validate);\n    }\n    return resolveArbitraryValue(modifier, validate);\n}\nfunction isArbitraryValue(input) {\n    return input.startsWith(\"[\") && input.endsWith(\"]\");\n}\nfunction splitUtilityModifier(modifier) {\n    let slashIdx = modifier.lastIndexOf(\"/\");\n    // If the `/` is inside an arbitrary, we want to find the previous one if any\n    // This logic probably isn't perfect but it should work for most cases\n    let arbitraryStartIdx = modifier.lastIndexOf(\"[\", slashIdx);\n    let arbitraryEndIdx = modifier.indexOf(\"]\", slashIdx);\n    let isNextToArbitrary = modifier[slashIdx - 1] === \"]\" || modifier[slashIdx + 1] === \"[\";\n    // Backtrack to the previous `/` if the one we found was inside an arbitrary\n    if (!isNextToArbitrary) {\n        if (arbitraryStartIdx !== -1 && arbitraryEndIdx !== -1) {\n            if (arbitraryStartIdx < slashIdx && slashIdx < arbitraryEndIdx) {\n                slashIdx = modifier.lastIndexOf(\"/\", arbitraryStartIdx);\n            }\n        }\n    }\n    if (slashIdx === -1 || slashIdx === modifier.length - 1) {\n        return [\n            modifier,\n            undefined\n        ];\n    }\n    let arbitrary = isArbitraryValue(modifier);\n    // The modifier could be of the form `[foo]/[bar]`\n    // We want to handle this case properly\n    // without affecting `[foo/bar]`\n    if (arbitrary && !modifier.includes(\"]/[\")) {\n        return [\n            modifier,\n            undefined\n        ];\n    }\n    return [\n        modifier.slice(0, slashIdx),\n        modifier.slice(slashIdx + 1)\n    ];\n}\nfunction parseColorFormat(value) {\n    if (typeof value === \"string\" && value.includes(\"<alpha-value>\")) {\n        let oldValue = value;\n        return ({ opacityValue =1  })=>oldValue.replace(/<alpha-value>/g, opacityValue);\n    }\n    return value;\n}\nfunction unwrapArbitraryModifier(modifier) {\n    return (0, _dataTypes.normalize)(modifier.slice(1, -1));\n}\nfunction asColor(modifier, options = {}, { tailwindConfig ={}  } = {}) {\n    var _options_values;\n    if (((_options_values = options.values) === null || _options_values === void 0 ? void 0 : _options_values[modifier]) !== undefined) {\n        var _options_values1;\n        return parseColorFormat((_options_values1 = options.values) === null || _options_values1 === void 0 ? void 0 : _options_values1[modifier]);\n    }\n    // TODO: Hoist this up to getMatchingTypes or something\n    // We do this here because we need the alpha value (if any)\n    let [color, alpha] = splitUtilityModifier(modifier);\n    if (alpha !== undefined) {\n        var _options_values2, _tailwindConfig_theme, _tailwindConfig_theme_opacity;\n        var _options_values_color;\n        let normalizedColor = (_options_values_color = (_options_values2 = options.values) === null || _options_values2 === void 0 ? void 0 : _options_values2[color]) !== null && _options_values_color !== void 0 ? _options_values_color : isArbitraryValue(color) ? color.slice(1, -1) : undefined;\n        if (normalizedColor === undefined) {\n            return undefined;\n        }\n        normalizedColor = parseColorFormat(normalizedColor);\n        if (isArbitraryValue(alpha)) {\n            return (0, _withAlphaVariable.withAlphaValue)(normalizedColor, unwrapArbitraryModifier(alpha));\n        }\n        if (((_tailwindConfig_theme = tailwindConfig.theme) === null || _tailwindConfig_theme === void 0 ? void 0 : (_tailwindConfig_theme_opacity = _tailwindConfig_theme.opacity) === null || _tailwindConfig_theme_opacity === void 0 ? void 0 : _tailwindConfig_theme_opacity[alpha]) === undefined) {\n            return undefined;\n        }\n        return (0, _withAlphaVariable.withAlphaValue)(normalizedColor, tailwindConfig.theme.opacity[alpha]);\n    }\n    return asValue(modifier, options, {\n        validate: _dataTypes.color\n    });\n}\nfunction asLookupValue(modifier, options = {}) {\n    var _options_values;\n    return (_options_values = options.values) === null || _options_values === void 0 ? void 0 : _options_values[modifier];\n}\nfunction guess(validate) {\n    return (modifier, options)=>{\n        return asValue(modifier, options, {\n            validate\n        });\n    };\n}\nlet typeMap = {\n    any: asValue,\n    color: asColor,\n    url: guess(_dataTypes.url),\n    image: guess(_dataTypes.image),\n    length: guess(_dataTypes.length),\n    percentage: guess(_dataTypes.percentage),\n    position: guess(_dataTypes.position),\n    lookup: asLookupValue,\n    \"generic-name\": guess(_dataTypes.genericName),\n    \"family-name\": guess(_dataTypes.familyName),\n    number: guess(_dataTypes.number),\n    \"line-width\": guess(_dataTypes.lineWidth),\n    \"absolute-size\": guess(_dataTypes.absoluteSize),\n    \"relative-size\": guess(_dataTypes.relativeSize),\n    shadow: guess(_dataTypes.shadow),\n    size: guess(_validateFormalSyntax.backgroundSize)\n};\nlet supportedTypes = Object.keys(typeMap);\nfunction splitAtFirst(input, delim) {\n    let idx = input.indexOf(delim);\n    if (idx === -1) return [\n        undefined,\n        input\n    ];\n    return [\n        input.slice(0, idx),\n        input.slice(idx + 1)\n    ];\n}\nfunction coerceValue(types, modifier, options, tailwindConfig) {\n    if (options.values && modifier in options.values) {\n        for (let { type  } of types !== null && types !== void 0 ? types : []){\n            let result = typeMap[type](modifier, options, {\n                tailwindConfig\n            });\n            if (result === undefined) {\n                continue;\n            }\n            return [\n                result,\n                type,\n                null\n            ];\n        }\n    }\n    if (isArbitraryValue(modifier)) {\n        let arbitraryValue = modifier.slice(1, -1);\n        let [explicitType, value] = splitAtFirst(arbitraryValue, \":\");\n        // It could be that this resolves to `url(https` which is not a valid\n        // identifier. We currently only support \"simple\" words with dashes or\n        // underscores. E.g.: family-name\n        if (!/^[\\w-_]+$/g.test(explicitType)) {\n            value = arbitraryValue;\n        } else if (explicitType !== undefined && !supportedTypes.includes(explicitType)) {\n            return [];\n        }\n        if (value.length > 0 && supportedTypes.includes(explicitType)) {\n            return [\n                asValue(`[${value}]`, options),\n                explicitType,\n                null\n            ];\n        }\n    }\n    let matches = getMatchingTypes(types, modifier, options, tailwindConfig);\n    // Find first matching type\n    for (let match of matches){\n        return match;\n    }\n    return [];\n}\nfunction* getMatchingTypes(types, rawModifier, options, tailwindConfig) {\n    let modifiersEnabled = (0, _featureFlags.flagEnabled)(tailwindConfig, \"generalizedModifiers\");\n    let [modifier, utilityModifier] = splitUtilityModifier(rawModifier);\n    let canUseUtilityModifier = modifiersEnabled && options.modifiers != null && (options.modifiers === \"any\" || typeof options.modifiers === \"object\" && (utilityModifier && isArbitraryValue(utilityModifier) || utilityModifier in options.modifiers));\n    if (!canUseUtilityModifier) {\n        modifier = rawModifier;\n        utilityModifier = undefined;\n    }\n    if (utilityModifier !== undefined && modifier === \"\") {\n        modifier = \"DEFAULT\";\n    }\n    // Check the full value first\n    // TODO: Move to asValue… somehow\n    if (utilityModifier !== undefined) {\n        if (typeof options.modifiers === \"object\") {\n            var _options_modifiers;\n            var _options_modifiers_utilityModifier;\n            let configValue = (_options_modifiers_utilityModifier = (_options_modifiers = options.modifiers) === null || _options_modifiers === void 0 ? void 0 : _options_modifiers[utilityModifier]) !== null && _options_modifiers_utilityModifier !== void 0 ? _options_modifiers_utilityModifier : null;\n            if (configValue !== null) {\n                utilityModifier = configValue;\n            } else if (isArbitraryValue(utilityModifier)) {\n                utilityModifier = unwrapArbitraryModifier(utilityModifier);\n            }\n        }\n    }\n    for (let { type  } of types !== null && types !== void 0 ? types : []){\n        let result = typeMap[type](modifier, options, {\n            tailwindConfig\n        });\n        if (result === undefined) {\n            continue;\n        }\n        yield [\n            result,\n            type,\n            utilityModifier !== null && utilityModifier !== void 0 ? utilityModifier : null\n        ];\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}