{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nfunction _export(target, all) {\n  for (var name in all) Object.defineProperty(target, name, {\n    enumerable: true,\n    get: all[name]\n  });\n}\n_export(exports, {\n  getClassNameFromSelector: function () {\n    return getClassNameFromSelector;\n  },\n  resolveMatches: function () {\n    return resolveMatches;\n  },\n  generateRules: function () {\n    return generateRules;\n  }\n});\nconst _postcss = /*#__PURE__*/_interop_require_default(require(\"postcss\"));\nconst _postcssselectorparser = /*#__PURE__*/_interop_require_default(require(\"postcss-selector-parser\"));\nconst _parseObjectStyles = /*#__PURE__*/_interop_require_default(require(\"../util/parseObjectStyles\"));\nconst _isPlainObject = /*#__PURE__*/_interop_require_default(require(\"../util/isPlainObject\"));\nconst _prefixSelector = /*#__PURE__*/_interop_require_default(require(\"../util/prefixSelector\"));\nconst _pluginUtils = require(\"../util/pluginUtils\");\nconst _log = /*#__PURE__*/_interop_require_default(require(\"../util/log\"));\nconst _sharedState = /*#__PURE__*/_interop_require_wildcard(require(\"./sharedState\"));\nconst _formatVariantSelector = require(\"../util/formatVariantSelector\");\nconst _nameClass = require(\"../util/nameClass\");\nconst _dataTypes = require(\"../util/dataTypes\");\nconst _setupContextUtils = require(\"./setupContextUtils\");\nconst _isSyntacticallyValidPropertyValue = /*#__PURE__*/_interop_require_default(require(\"../util/isSyntacticallyValidPropertyValue\"));\nconst _splitAtTopLevelOnly = require(\"../util/splitAtTopLevelOnly.js\");\nconst _featureFlags = require(\"../featureFlags\");\nconst _applyImportantSelector = require(\"../util/applyImportantSelector\");\nfunction _interop_require_default(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== \"function\") return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function (nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\nfunction _interop_require_wildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n  var cache = _getRequireWildcardCache(nodeInterop);\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n  for (var key in obj) {\n    if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n  newObj.default = obj;\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n  return newObj;\n}\nlet classNameParser = (0, _postcssselectorparser.default)(selectors => {\n  return selectors.first.filter(({\n    type\n  }) => type === \"class\").pop().value;\n});\nfunction getClassNameFromSelector(selector) {\n  return classNameParser.transformSync(selector);\n}\n// Generate match permutations for a class candidate, like:\n// ['ring-offset-blue', '100']\n// ['ring-offset', 'blue-100']\n// ['ring', 'offset-blue-100']\n// Example with dynamic classes:\n// ['grid-cols', '[[linename],1fr,auto]']\n// ['grid', 'cols-[[linename],1fr,auto]']\nfunction* candidatePermutations(candidate) {\n  let lastIndex = Infinity;\n  while (lastIndex >= 0) {\n    let dashIdx;\n    let wasSlash = false;\n    if (lastIndex === Infinity && candidate.endsWith(\"]\")) {\n      let bracketIdx = candidate.indexOf(\"[\");\n      // If character before `[` isn't a dash or a slash, this isn't a dynamic class\n      // eg. string[]\n      if (candidate[bracketIdx - 1] === \"-\") {\n        dashIdx = bracketIdx - 1;\n      } else if (candidate[bracketIdx - 1] === \"/\") {\n        dashIdx = bracketIdx - 1;\n        wasSlash = true;\n      } else {\n        dashIdx = -1;\n      }\n    } else if (lastIndex === Infinity && candidate.includes(\"/\")) {\n      dashIdx = candidate.lastIndexOf(\"/\");\n      wasSlash = true;\n    } else {\n      dashIdx = candidate.lastIndexOf(\"-\", lastIndex);\n    }\n    if (dashIdx < 0) {\n      break;\n    }\n    let prefix = candidate.slice(0, dashIdx);\n    let modifier = candidate.slice(wasSlash ? dashIdx : dashIdx + 1);\n    lastIndex = dashIdx - 1;\n    // TODO: This feels a bit hacky\n    if (prefix === \"\" || modifier === \"/\") {\n      continue;\n    }\n    yield [prefix, modifier];\n  }\n}\nfunction applyPrefix(matches, context) {\n  if (matches.length === 0 || context.tailwindConfig.prefix === \"\") {\n    return matches;\n  }\n  for (let match of matches) {\n    let [meta] = match;\n    if (meta.options.respectPrefix) {\n      let container = _postcss.default.root({\n        nodes: [match[1].clone()]\n      });\n      let classCandidate = match[1].raws.tailwind.classCandidate;\n      container.walkRules(r => {\n        // If this is a negative utility with a dash *before* the prefix we\n        // have to ensure that the generated selector matches the candidate\n        // Not doing this will cause `-tw-top-1` to generate the class `.tw--top-1`\n        // The disconnect between candidate <-> class can cause @apply to hard crash.\n        let shouldPrependNegative = classCandidate.startsWith(\"-\");\n        r.selector = (0, _prefixSelector.default)(context.tailwindConfig.prefix, r.selector, shouldPrependNegative);\n      });\n      match[1] = container.nodes[0];\n    }\n  }\n  return matches;\n}\nfunction applyImportant(matches, classCandidate) {\n  if (matches.length === 0) {\n    return matches;\n  }\n  let result = [];\n  function isInKeyframes(rule) {\n    return rule.parent && rule.parent.type === \"atrule\" && rule.parent.name === \"keyframes\";\n  }\n  for (let [meta, rule] of matches) {\n    let container = _postcss.default.root({\n      nodes: [rule.clone()]\n    });\n    container.walkRules(r => {\n      // Declarations inside keyframes cannot be marked as important\n      // They will be ignored by the browser\n      if (isInKeyframes(r)) {\n        return;\n      }\n      let ast = (0, _postcssselectorparser.default)().astSync(r.selector);\n      // Remove extraneous selectors that do not include the base candidate\n      ast.each(sel => (0, _formatVariantSelector.eliminateIrrelevantSelectors)(sel, classCandidate));\n      // Update all instances of the base candidate to include the important marker\n      (0, _pluginUtils.updateAllClasses)(ast, className => className === classCandidate ? `!${className}` : className);\n      r.selector = ast.toString();\n      r.walkDecls(d => d.important = true);\n    });\n    result.push([{\n      ...meta,\n      important: true\n    }, container.nodes[0]]);\n  }\n  return result;\n}\n// Takes a list of rule tuples and applies a variant like `hover`, sm`,\n// whatever to it. We used to do some extra caching here to avoid generating\n// a variant of the same rule more than once, but this was never hit because\n// we cache at the entire selector level further up the tree.\n//\n// Technically you can get a cache hit if you have `hover:focus:text-center`\n// and `focus:hover:text-center` in the same project, but it doesn't feel\n// worth the complexity for that case.\nfunction applyVariant(variant, matches, context) {\n  if (matches.length === 0) {\n    return matches;\n  }\n  /** @type {{modifier: string | null, value: string | null}} */\n  let args = {\n    modifier: null,\n    value: _sharedState.NONE\n  };\n  // Retrieve \"modifier\"\n  {\n    let [baseVariant, ...modifiers] = (0, _splitAtTopLevelOnly.splitAtTopLevelOnly)(variant, \"/\");\n    // This is a hack to support variants with `/` in them, like `ar-1/10/20:text-red-500`\n    // In this case 1/10 is a value but /20 is a modifier\n    if (modifiers.length > 1) {\n      baseVariant = baseVariant + \"/\" + modifiers.slice(0, -1).join(\"/\");\n      modifiers = modifiers.slice(-1);\n    }\n    if (modifiers.length && !context.variantMap.has(variant)) {\n      variant = baseVariant;\n      args.modifier = modifiers[0];\n      if (!(0, _featureFlags.flagEnabled)(context.tailwindConfig, \"generalizedModifiers\")) {\n        return [];\n      }\n    }\n  }\n  // Retrieve \"arbitrary value\"\n  if (variant.endsWith(\"]\") && !variant.startsWith(\"[\")) {\n    // We either have:\n    //   @[200px]\n    //   group-[:hover]\n    //\n    // But we don't want:\n    //   @-[200px]        (`-` is incorrect)\n    //   group[:hover]    (`-` is missing)\n    let match = /(.)(-?)\\[(.*)\\]/g.exec(variant);\n    if (match) {\n      let [, char, separator, value] = match;\n      // @-[200px] case\n      if (char === \"@\" && separator === \"-\") return [];\n      // group[:hover] case\n      if (char !== \"@\" && separator === \"\") return [];\n      variant = variant.replace(`${separator}[${value}]`, \"\");\n      args.value = value;\n    }\n  }\n  // Register arbitrary variants\n  if (isArbitraryValue(variant) && !context.variantMap.has(variant)) {\n    let sort = context.offsets.recordVariant(variant);\n    let selector = (0, _dataTypes.normalize)(variant.slice(1, -1));\n    let selectors = (0, _splitAtTopLevelOnly.splitAtTopLevelOnly)(selector, \",\");\n    // We do not support multiple selectors for arbitrary variants\n    if (selectors.length > 1) {\n      return [];\n    }\n    if (!selectors.every(_setupContextUtils.isValidVariantFormatString)) {\n      return [];\n    }\n    let records = selectors.map((sel, idx) => [context.offsets.applyParallelOffset(sort, idx), (0, _setupContextUtils.parseVariant)(sel.trim())]);\n    context.variantMap.set(variant, records);\n  }\n  if (context.variantMap.has(variant)) {\n    var _context_variantOptions_get;\n    let isArbitraryVariant = isArbitraryValue(variant);\n    var _context_variantOptions_get_INTERNAL_FEATURES;\n    let internalFeatures = (_context_variantOptions_get_INTERNAL_FEATURES = (_context_variantOptions_get = context.variantOptions.get(variant)) === null || _context_variantOptions_get === void 0 ? void 0 : _context_variantOptions_get[_setupContextUtils.INTERNAL_FEATURES]) !== null && _context_variantOptions_get_INTERNAL_FEATURES !== void 0 ? _context_variantOptions_get_INTERNAL_FEATURES : {};\n    let variantFunctionTuples = context.variantMap.get(variant).slice();\n    let result = [];\n    let respectPrefix = (() => {\n      if (isArbitraryVariant) return false;\n      if (internalFeatures.respectPrefix === false) return false;\n      return true;\n    })();\n    for (let [meta, rule] of matches) {\n      // Don't generate variants for user css\n      if (meta.layer === \"user\") {\n        continue;\n      }\n      let container = _postcss.default.root({\n        nodes: [rule.clone()]\n      });\n      for (let [variantSort, variantFunction, containerFromArray] of variantFunctionTuples) {\n        let clone = (containerFromArray !== null && containerFromArray !== void 0 ? containerFromArray : container).clone();\n        let collectedFormats = [];\n        function prepareBackup() {\n          // Already prepared, chicken out\n          if (clone.raws.neededBackup) {\n            return;\n          }\n          clone.raws.neededBackup = true;\n          clone.walkRules(rule => rule.raws.originalSelector = rule.selector);\n        }\n        function modifySelectors(modifierFunction) {\n          prepareBackup();\n          clone.each(rule => {\n            if (rule.type !== \"rule\") {\n              return;\n            }\n            rule.selectors = rule.selectors.map(selector => {\n              return modifierFunction({\n                get className() {\n                  return getClassNameFromSelector(selector);\n                },\n                selector\n              });\n            });\n          });\n          return clone;\n        }\n        let ruleWithVariant = variantFunction({\n          // Public API\n          get container() {\n            prepareBackup();\n            return clone;\n          },\n          separator: context.tailwindConfig.separator,\n          modifySelectors,\n          // Private API for now\n          wrap(wrapper) {\n            let nodes = clone.nodes;\n            clone.removeAll();\n            wrapper.append(nodes);\n            clone.append(wrapper);\n          },\n          format(selectorFormat) {\n            collectedFormats.push({\n              format: selectorFormat,\n              respectPrefix\n            });\n          },\n          args\n        });\n        // It can happen that a list of format strings is returned from within the function. In that\n        // case, we have to process them as well. We can use the existing `variantSort`.\n        if (Array.isArray(ruleWithVariant)) {\n          for (let [idx, variantFunction] of ruleWithVariant.entries()) {\n            // This is a little bit scary since we are pushing to an array of items that we are\n            // currently looping over. However, you can also think of it like a processing queue\n            // where you keep handling jobs until everything is done and each job can queue more\n            // jobs if needed.\n            variantFunctionTuples.push([context.offsets.applyParallelOffset(variantSort, idx), variantFunction,\n            // If the clone has been modified we have to pass that back\n            // though so each rule can use the modified container\n            clone.clone()]);\n          }\n          continue;\n        }\n        if (typeof ruleWithVariant === \"string\") {\n          collectedFormats.push({\n            format: ruleWithVariant,\n            respectPrefix\n          });\n        }\n        if (ruleWithVariant === null) {\n          continue;\n        }\n        // We had to backup selectors, therefore we assume that somebody touched\n        // `container` or `modifySelectors`. Let's see if they did, so that we\n        // can restore the selectors, and collect the format strings.\n        if (clone.raws.neededBackup) {\n          delete clone.raws.neededBackup;\n          clone.walkRules(rule => {\n            let before = rule.raws.originalSelector;\n            if (!before) return;\n            delete rule.raws.originalSelector;\n            if (before === rule.selector) return; // No mutation happened\n            let modified = rule.selector;\n            // Rebuild the base selector, this is what plugin authors would do\n            // as well. E.g.: `${variant}${separator}${className}`.\n            // However, plugin authors probably also prepend or append certain\n            // classes, pseudos, ids, ...\n            let rebuiltBase = (0, _postcssselectorparser.default)(selectors => {\n              selectors.walkClasses(classNode => {\n                classNode.value = `${variant}${context.tailwindConfig.separator}${classNode.value}`;\n              });\n            }).processSync(before);\n            // Now that we know the original selector, the new selector, and\n            // the rebuild part in between, we can replace the part that plugin\n            // authors need to rebuild with `&`, and eventually store it in the\n            // collectedFormats. Similar to what `format('...')` would do.\n            //\n            // E.g.:\n            //                   variant: foo\n            //                  selector: .markdown > p\n            //      modified (by plugin): .foo .foo\\\\:markdown > p\n            //    rebuiltBase (internal): .foo\\\\:markdown > p\n            //                    format: .foo &\n            collectedFormats.push({\n              format: modified.replace(rebuiltBase, \"&\"),\n              respectPrefix\n            });\n            rule.selector = before;\n          });\n        }\n        // This tracks the originating layer for the variant\n        // For example:\n        // .sm:underline {} is a variant of something in the utilities layer\n        // .sm:container {} is a variant of the container component\n        clone.nodes[0].raws.tailwind = {\n          ...clone.nodes[0].raws.tailwind,\n          parentLayer: meta.layer\n        };\n        var _meta_collectedFormats;\n        let withOffset = [{\n          ...meta,\n          sort: context.offsets.applyVariantOffset(meta.sort, variantSort, Object.assign(args, context.variantOptions.get(variant))),\n          collectedFormats: ((_meta_collectedFormats = meta.collectedFormats) !== null && _meta_collectedFormats !== void 0 ? _meta_collectedFormats : []).concat(collectedFormats)\n        }, clone.nodes[0]];\n        result.push(withOffset);\n      }\n    }\n    return result;\n  }\n  return [];\n}\nfunction parseRules(rule, cache, options = {}) {\n  // PostCSS node\n  if (!(0, _isPlainObject.default)(rule) && !Array.isArray(rule)) {\n    return [[rule], options];\n  }\n  // Tuple\n  if (Array.isArray(rule)) {\n    return parseRules(rule[0], cache, rule[1]);\n  }\n  // Simple object\n  if (!cache.has(rule)) {\n    cache.set(rule, (0, _parseObjectStyles.default)(rule));\n  }\n  return [cache.get(rule), options];\n}\nconst IS_VALID_PROPERTY_NAME = /^[a-z_-]/;\nfunction isValidPropName(name) {\n  return IS_VALID_PROPERTY_NAME.test(name);\n}\n/**\n * @param {string} declaration\n * @returns {boolean}\n */\nfunction looksLikeUri(declaration) {\n  // Quick bailout for obvious non-urls\n  // This doesn't support schemes that don't use a leading // but that's unlikely to be a problem\n  if (!declaration.includes(\"://\")) {\n    return false;\n  }\n  try {\n    const url = new URL(declaration);\n    return url.scheme !== \"\" && url.host !== \"\";\n  } catch (err) {\n    // Definitely not a valid url\n    return false;\n  }\n}\nfunction isParsableNode(node) {\n  let isParsable = true;\n  node.walkDecls(decl => {\n    if (!isParsableCssValue(decl.prop, decl.value)) {\n      isParsable = false;\n      return false;\n    }\n  });\n  return isParsable;\n}\nfunction isParsableCssValue(property, value) {\n  // We don't want to to treat [https://example.com] as a custom property\n  // Even though, according to the CSS grammar, it's a totally valid CSS declaration\n  // So we short-circuit here by checking if the custom property looks like a url\n  if (looksLikeUri(`${property}:${value}`)) {\n    return false;\n  }\n  try {\n    _postcss.default.parse(`a{${property}:${value}}`).toResult();\n    return true;\n  } catch (err) {\n    return false;\n  }\n}\nfunction extractArbitraryProperty(classCandidate, context) {\n  var _classCandidate_match;\n  let [, property, value] = (_classCandidate_match = classCandidate.match(/^\\[([a-zA-Z0-9-_]+):(\\S+)\\]$/)) !== null && _classCandidate_match !== void 0 ? _classCandidate_match : [];\n  if (value === undefined) {\n    return null;\n  }\n  if (!isValidPropName(property)) {\n    return null;\n  }\n  if (!(0, _isSyntacticallyValidPropertyValue.default)(value)) {\n    return null;\n  }\n  let normalized = (0, _dataTypes.normalize)(value, {\n    property\n  });\n  if (!isParsableCssValue(property, normalized)) {\n    return null;\n  }\n  let sort = context.offsets.arbitraryProperty(classCandidate);\n  return [[{\n    sort,\n    layer: \"utilities\",\n    options: {\n      respectImportant: true\n    }\n  }, () => ({\n    [(0, _nameClass.asClass)(classCandidate)]: {\n      [property]: normalized\n    }\n  })]];\n}\nfunction* resolveMatchedPlugins(classCandidate, context) {\n  if (context.candidateRuleMap.has(classCandidate)) {\n    yield [context.candidateRuleMap.get(classCandidate), \"DEFAULT\"];\n  }\n  yield* function* (arbitraryPropertyRule) {\n    if (arbitraryPropertyRule !== null) {\n      yield [arbitraryPropertyRule, \"DEFAULT\"];\n    }\n  }(extractArbitraryProperty(classCandidate, context));\n  let candidatePrefix = classCandidate;\n  let negative = false;\n  const twConfigPrefix = context.tailwindConfig.prefix;\n  const twConfigPrefixLen = twConfigPrefix.length;\n  const hasMatchingPrefix = candidatePrefix.startsWith(twConfigPrefix) || candidatePrefix.startsWith(`-${twConfigPrefix}`);\n  if (candidatePrefix[twConfigPrefixLen] === \"-\" && hasMatchingPrefix) {\n    negative = true;\n    candidatePrefix = twConfigPrefix + candidatePrefix.slice(twConfigPrefixLen + 1);\n  }\n  if (negative && context.candidateRuleMap.has(candidatePrefix)) {\n    yield [context.candidateRuleMap.get(candidatePrefix), \"-DEFAULT\"];\n  }\n  for (let [prefix, modifier] of candidatePermutations(candidatePrefix)) {\n    if (context.candidateRuleMap.has(prefix)) {\n      yield [context.candidateRuleMap.get(prefix), negative ? `-${modifier}` : modifier];\n    }\n  }\n}\nfunction splitWithSeparator(input, separator) {\n  if (input === _sharedState.NOT_ON_DEMAND) {\n    return [_sharedState.NOT_ON_DEMAND];\n  }\n  return (0, _splitAtTopLevelOnly.splitAtTopLevelOnly)(input, separator);\n}\nfunction* recordCandidates(matches, classCandidate) {\n  for (const match of matches) {\n    var _match__options;\n    var _match__options_preserveSource;\n    match[1].raws.tailwind = {\n      ...match[1].raws.tailwind,\n      classCandidate,\n      preserveSource: (_match__options_preserveSource = (_match__options = match[0].options) === null || _match__options === void 0 ? void 0 : _match__options.preserveSource) !== null && _match__options_preserveSource !== void 0 ? _match__options_preserveSource : false\n    };\n    yield match;\n  }\n}\nfunction* resolveMatches(candidate, context) {\n  let separator = context.tailwindConfig.separator;\n  let [classCandidate, ...variants] = splitWithSeparator(candidate, separator).reverse();\n  let important = false;\n  if (classCandidate.startsWith(\"!\")) {\n    important = true;\n    classCandidate = classCandidate.slice(1);\n  }\n  // TODO: Reintroduce this in ways that doesn't break on false positives\n  // function sortAgainst(toSort, against) {\n  //   return toSort.slice().sort((a, z) => {\n  //     return bigSign(against.get(a)[0] - against.get(z)[0])\n  //   })\n  // }\n  // let sorted = sortAgainst(variants, context.variantMap)\n  // if (sorted.toString() !== variants.toString()) {\n  //   let corrected = sorted.reverse().concat(classCandidate).join(':')\n  //   throw new Error(`Class ${candidate} should be written as ${corrected}`)\n  // }\n  for (let matchedPlugins of resolveMatchedPlugins(classCandidate, context)) {\n    let matches = [];\n    let typesByMatches = new Map();\n    let [plugins, modifier] = matchedPlugins;\n    let isOnlyPlugin = plugins.length === 1;\n    for (let [sort, plugin] of plugins) {\n      let matchesPerPlugin = [];\n      if (typeof plugin === \"function\") {\n        for (let ruleSet of [].concat(plugin(modifier, {\n          isOnlyPlugin\n        }))) {\n          let [rules, options] = parseRules(ruleSet, context.postCssNodeCache);\n          for (let rule of rules) {\n            matchesPerPlugin.push([{\n              ...sort,\n              options: {\n                ...sort.options,\n                ...options\n              }\n            }, rule]);\n          }\n        }\n      } else if (modifier === \"DEFAULT\" || modifier === \"-DEFAULT\") {\n        let ruleSet = plugin;\n        let [rules, options] = parseRules(ruleSet, context.postCssNodeCache);\n        for (let rule of rules) {\n          matchesPerPlugin.push([{\n            ...sort,\n            options: {\n              ...sort.options,\n              ...options\n            }\n          }, rule]);\n        }\n      }\n      if (matchesPerPlugin.length > 0) {\n        var _sort_options;\n        var _sort_options_types, _sort_options1;\n        let matchingTypes = Array.from((0, _pluginUtils.getMatchingTypes)((_sort_options_types = (_sort_options = sort.options) === null || _sort_options === void 0 ? void 0 : _sort_options.types) !== null && _sort_options_types !== void 0 ? _sort_options_types : [], modifier, (_sort_options1 = sort.options) !== null && _sort_options1 !== void 0 ? _sort_options1 : {}, context.tailwindConfig)).map(([_, type]) => type);\n        if (matchingTypes.length > 0) {\n          typesByMatches.set(matchesPerPlugin, matchingTypes);\n        }\n        matches.push(matchesPerPlugin);\n      }\n    }\n    if (isArbitraryValue(modifier)) {\n      if (matches.length > 1) {\n        // Partition plugins in 2 categories so that we can start searching in the plugins that\n        // don't have `any` as a type first.\n        let [withAny, withoutAny] = matches.reduce((group, plugin) => {\n          let hasAnyType = plugin.some(([{\n            options\n          }]) => options.types.some(({\n            type\n          }) => type === \"any\"));\n          if (hasAnyType) {\n            group[0].push(plugin);\n          } else {\n            group[1].push(plugin);\n          }\n          return group;\n        }, [[], []]);\n        function findFallback(matches) {\n          // If only a single plugin matches, let's take that one\n          if (matches.length === 1) {\n            return matches[0];\n          }\n          // Otherwise, find the plugin that creates a valid rule given the arbitrary value, and\n          // also has the correct type which preferOnConflicts the plugin in case of clashes.\n          return matches.find(rules => {\n            let matchingTypes = typesByMatches.get(rules);\n            return rules.some(([{\n              options\n            }, rule]) => {\n              if (!isParsableNode(rule)) {\n                return false;\n              }\n              return options.types.some(({\n                type,\n                preferOnConflict\n              }) => matchingTypes.includes(type) && preferOnConflict);\n            });\n          });\n        }\n        var _findFallback;\n        // Try to find a fallback plugin, because we already know that multiple plugins matched for\n        // the given arbitrary value.\n        let fallback = (_findFallback = findFallback(withoutAny)) !== null && _findFallback !== void 0 ? _findFallback : findFallback(withAny);\n        if (fallback) {\n          matches = [fallback];\n        } else {\n          var _typesByMatches_get;\n          let typesPerPlugin = matches.map(match => new Set([...((_typesByMatches_get = typesByMatches.get(match)) !== null && _typesByMatches_get !== void 0 ? _typesByMatches_get : [])]));\n          // Remove duplicates, so that we can detect proper unique types for each plugin.\n          for (let pluginTypes of typesPerPlugin) {\n            for (let type of pluginTypes) {\n              let removeFromOwnGroup = false;\n              for (let otherGroup of typesPerPlugin) {\n                if (pluginTypes === otherGroup) continue;\n                if (otherGroup.has(type)) {\n                  otherGroup.delete(type);\n                  removeFromOwnGroup = true;\n                }\n              }\n              if (removeFromOwnGroup) pluginTypes.delete(type);\n            }\n          }\n          let messages = [];\n          for (let [idx, group] of typesPerPlugin.entries()) {\n            for (let type of group) {\n              let rules = matches[idx].map(([, rule]) => rule).flat().map(rule => rule.toString().split(\"\\n\").slice(1, -1) // Remove selector and closing '}'\n              .map(line => line.trim()).map(x => `      ${x}`) // Re-indent\n              .join(\"\\n\")).join(\"\\n\\n\");\n              messages.push(`  Use \\`${candidate.replace(\"[\", `[${type}:`)}\\` for \\`${rules.trim()}\\``);\n              break;\n            }\n          }\n          _log.default.warn([`The class \\`${candidate}\\` is ambiguous and matches multiple utilities.`, ...messages, `If this is content and not a class, replace it with \\`${candidate.replace(\"[\", \"&lsqb;\").replace(\"]\", \"&rsqb;\")}\\` to silence this warning.`]);\n          continue;\n        }\n      }\n      matches = matches.map(list => list.filter(match => isParsableNode(match[1])));\n    }\n    matches = matches.flat();\n    matches = Array.from(recordCandidates(matches, classCandidate));\n    matches = applyPrefix(matches, context);\n    if (important) {\n      matches = applyImportant(matches, classCandidate);\n    }\n    for (let variant of variants) {\n      matches = applyVariant(variant, matches, context);\n    }\n    for (let match of matches) {\n      match[1].raws.tailwind = {\n        ...match[1].raws.tailwind,\n        candidate\n      };\n      // Apply final format selector\n      match = applyFinalFormat(match, {\n        context,\n        candidate\n      });\n      // Skip rules with invalid selectors\n      // This will cause the candidate to be added to the \"not class\"\n      // cache skipping it entirely for future builds\n      if (match === null) {\n        continue;\n      }\n      yield match;\n    }\n  }\n}\nfunction applyFinalFormat(match, {\n  context,\n  candidate\n}) {\n  if (!match[0].collectedFormats) {\n    return match;\n  }\n  let isValid = true;\n  let finalFormat;\n  try {\n    finalFormat = (0, _formatVariantSelector.formatVariantSelector)(match[0].collectedFormats, {\n      context,\n      candidate\n    });\n  } catch {\n    // The format selector we produced is invalid\n    // This could be because:\n    // - A bug exists\n    // - A plugin introduced an invalid variant selector (ex: `addVariant('foo', '&;foo')`)\n    // - The user used an invalid arbitrary variant (ex: `[&;foo]:underline`)\n    // Either way the build will fail because of this\n    // We would rather that the build pass \"silently\" given that this could\n    // happen because of picking up invalid things when scanning content\n    // So we'll throw out the candidate instead\n    return null;\n  }\n  let container = _postcss.default.root({\n    nodes: [match[1].clone()]\n  });\n  container.walkRules(rule => {\n    if (inKeyframes(rule)) {\n      return;\n    }\n    try {\n      let selector = (0, _formatVariantSelector.finalizeSelector)(rule.selector, finalFormat, {\n        candidate,\n        context\n      });\n      // Finalize Selector determined that this candidate is irrelevant\n      // TODO: This elimination should happen earlier so this never happens\n      if (selector === null) {\n        rule.remove();\n        return;\n      }\n      rule.selector = selector;\n    } catch {\n      // If this selector is invalid we also want to skip it\n      // But it's likely that being invalid here means there's a bug in a plugin rather than too loosely matching content\n      isValid = false;\n      return false;\n    }\n  });\n  if (!isValid) {\n    return null;\n  }\n  // If all rules have been eliminated we can skip this candidate entirely\n  if (container.nodes.length === 0) {\n    return null;\n  }\n  match[1] = container.nodes[0];\n  return match;\n}\nfunction inKeyframes(rule) {\n  return rule.parent && rule.parent.type === \"atrule\" && rule.parent.name === \"keyframes\";\n}\nfunction getImportantStrategy(important) {\n  if (important === true) {\n    return rule => {\n      if (inKeyframes(rule)) {\n        return;\n      }\n      rule.walkDecls(d => {\n        if (d.parent.type === \"rule\" && !inKeyframes(d.parent)) {\n          d.important = true;\n        }\n      });\n    };\n  }\n  if (typeof important === \"string\") {\n    return rule => {\n      if (inKeyframes(rule)) {\n        return;\n      }\n      rule.selectors = rule.selectors.map(selector => {\n        return (0, _applyImportantSelector.applyImportantSelector)(selector, important);\n      });\n    };\n  }\n}\nfunction generateRules(candidates, context, isSorting = false) {\n  let allRules = [];\n  let strategy = getImportantStrategy(context.tailwindConfig.important);\n  for (let candidate of candidates) {\n    if (context.notClassCache.has(candidate)) {\n      continue;\n    }\n    if (context.candidateRuleCache.has(candidate)) {\n      allRules = allRules.concat(Array.from(context.candidateRuleCache.get(candidate)));\n      continue;\n    }\n    let matches = Array.from(resolveMatches(candidate, context));\n    if (matches.length === 0) {\n      context.notClassCache.add(candidate);\n      continue;\n    }\n    context.classCache.set(candidate, matches);\n    var _context_candidateRuleCache_get;\n    let rules = (_context_candidateRuleCache_get = context.candidateRuleCache.get(candidate)) !== null && _context_candidateRuleCache_get !== void 0 ? _context_candidateRuleCache_get : new Set();\n    context.candidateRuleCache.set(candidate, rules);\n    for (const match of matches) {\n      let [{\n        sort,\n        options\n      }, rule] = match;\n      if (options.respectImportant && strategy) {\n        let container = _postcss.default.root({\n          nodes: [rule.clone()]\n        });\n        container.walkRules(strategy);\n        rule = container.nodes[0];\n      }\n      // Note: We have to clone rules during sorting\n      // so we eliminate some shared mutable state\n      let newEntry = [sort, isSorting ? rule.clone() : rule];\n      rules.add(newEntry);\n      context.ruleCache.add(newEntry);\n      allRules.push(newEntry);\n    }\n  }\n  return allRules;\n}\nfunction isArbitraryValue(input) {\n  return input.startsWith(\"[\") && input.endsWith(\"]\");\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","_export","target","all","name","enumerable","get","getClassNameFromSelector","resolveMatches","generateRules","_postcss","_interop_require_default","require","_postcssselectorparser","_parseObjectStyles","_isPlainObject","_prefixSelector","_pluginUtils","_log","_sharedState","_interop_require_wildcard","_formatVariantSelector","_nameClass","_dataTypes","_setupContextUtils","_isSyntacticallyValidPropertyValue","_splitAtTopLevelOnly","_featureFlags","_applyImportantSelector","obj","__esModule","default","_getRequireWildcardCache","nodeInterop","WeakMap","cacheBabelInterop","cacheNodeInterop","cache","has","newObj","hasPropertyDescriptor","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","classNameParser","selectors","first","filter","type","pop","selector","transformSync","candidatePermutations","candidate","lastIndex","Infinity","dashIdx","wasSlash","endsWith","bracketIdx","indexOf","includes","lastIndexOf","prefix","slice","modifier","applyPrefix","matches","context","length","tailwindConfig","match","meta","options","respectPrefix","container","root","nodes","clone","classCandidate","raws","tailwind","walkRules","r","shouldPrependNegative","startsWith","applyImportant","result","isInKeyframes","rule","parent","ast","astSync","each","sel","eliminateIrrelevantSelectors","updateAllClasses","className","toString","walkDecls","d","important","push","applyVariant","variant","args","NONE","baseVariant","modifiers","splitAtTopLevelOnly","join","variantMap","flagEnabled","exec","char","separator","replace","isArbitraryValue","sort","offsets","recordVariant","normalize","every","isValidVariantFormatString","records","map","idx","applyParallelOffset","parseVariant","trim","_context_variantOptions_get","isArbitraryVariant","_context_variantOptions_get_INTERNAL_FEATURES","internalFeatures","variantOptions","INTERNAL_FEATURES","variantFunctionTuples","layer","variantSort","variantFunction","containerFromArray","collectedFormats","prepareBackup","neededBackup","originalSelector","modifySelectors","modifierFunction","ruleWithVariant","wrap","wrapper","removeAll","append","format","selectorFormat","Array","isArray","entries","before","modified","rebuiltBase","walkClasses","classNode","processSync","parentLayer","_meta_collectedFormats","withOffset","applyVariantOffset","assign","concat","parseRules","IS_VALID_PROPERTY_NAME","isValidPropName","test","looksLikeUri","declaration","url","URL","scheme","host","err","isParsableNode","node","isParsable","decl","isParsableCssValue","prop","property","parse","toResult","extractArbitraryProperty","_classCandidate_match","undefined","normalized","arbitraryProperty","respectImportant","asClass","resolveMatchedPlugins","candidateRuleMap","arbitraryPropertyRule","candidatePrefix","negative","twConfigPrefix","twConfigPrefixLen","hasMatchingPrefix","splitWithSeparator","input","NOT_ON_DEMAND","recordCandidates","_match__options","_match__options_preserveSource","preserveSource","variants","reverse","matchedPlugins","typesByMatches","Map","plugins","isOnlyPlugin","plugin","matchesPerPlugin","ruleSet","rules","postCssNodeCache","_sort_options","_sort_options_types","_sort_options1","matchingTypes","from","getMatchingTypes","types","_","withAny","withoutAny","reduce","group","hasAnyType","some","findFallback","find","preferOnConflict","_findFallback","fallback","_typesByMatches_get","typesPerPlugin","Set","pluginTypes","removeFromOwnGroup","otherGroup","delete","messages","flat","split","line","x","warn","list","applyFinalFormat","isValid","finalFormat","formatVariantSelector","inKeyframes","finalizeSelector","remove","getImportantStrategy","applyImportantSelector","candidates","isSorting","allRules","strategy","notClassCache","candidateRuleCache","add","classCache","_context_candidateRuleCache_get","newEntry","ruleCache"],"sources":["/Users/zeynepbas/Desktop/stackowerflow/node_modules/tailwindcss/lib/lib/generateRules.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    getClassNameFromSelector: function() {\n        return getClassNameFromSelector;\n    },\n    resolveMatches: function() {\n        return resolveMatches;\n    },\n    generateRules: function() {\n        return generateRules;\n    }\n});\nconst _postcss = /*#__PURE__*/ _interop_require_default(require(\"postcss\"));\nconst _postcssselectorparser = /*#__PURE__*/ _interop_require_default(require(\"postcss-selector-parser\"));\nconst _parseObjectStyles = /*#__PURE__*/ _interop_require_default(require(\"../util/parseObjectStyles\"));\nconst _isPlainObject = /*#__PURE__*/ _interop_require_default(require(\"../util/isPlainObject\"));\nconst _prefixSelector = /*#__PURE__*/ _interop_require_default(require(\"../util/prefixSelector\"));\nconst _pluginUtils = require(\"../util/pluginUtils\");\nconst _log = /*#__PURE__*/ _interop_require_default(require(\"../util/log\"));\nconst _sharedState = /*#__PURE__*/ _interop_require_wildcard(require(\"./sharedState\"));\nconst _formatVariantSelector = require(\"../util/formatVariantSelector\");\nconst _nameClass = require(\"../util/nameClass\");\nconst _dataTypes = require(\"../util/dataTypes\");\nconst _setupContextUtils = require(\"./setupContextUtils\");\nconst _isSyntacticallyValidPropertyValue = /*#__PURE__*/ _interop_require_default(require(\"../util/isSyntacticallyValidPropertyValue\"));\nconst _splitAtTopLevelOnly = require(\"../util/splitAtTopLevelOnly.js\");\nconst _featureFlags = require(\"../featureFlags\");\nconst _applyImportantSelector = require(\"../util/applyImportantSelector\");\nfunction _interop_require_default(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nfunction _getRequireWildcardCache(nodeInterop) {\n    if (typeof WeakMap !== \"function\") return null;\n    var cacheBabelInterop = new WeakMap();\n    var cacheNodeInterop = new WeakMap();\n    return (_getRequireWildcardCache = function(nodeInterop) {\n        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n    })(nodeInterop);\n}\nfunction _interop_require_wildcard(obj, nodeInterop) {\n    if (!nodeInterop && obj && obj.__esModule) {\n        return obj;\n    }\n    if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n        return {\n            default: obj\n        };\n    }\n    var cache = _getRequireWildcardCache(nodeInterop);\n    if (cache && cache.has(obj)) {\n        return cache.get(obj);\n    }\n    var newObj = {};\n    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for(var key in obj){\n        if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n            if (desc && (desc.get || desc.set)) {\n                Object.defineProperty(newObj, key, desc);\n            } else {\n                newObj[key] = obj[key];\n            }\n        }\n    }\n    newObj.default = obj;\n    if (cache) {\n        cache.set(obj, newObj);\n    }\n    return newObj;\n}\nlet classNameParser = (0, _postcssselectorparser.default)((selectors)=>{\n    return selectors.first.filter(({ type  })=>type === \"class\").pop().value;\n});\nfunction getClassNameFromSelector(selector) {\n    return classNameParser.transformSync(selector);\n}\n// Generate match permutations for a class candidate, like:\n// ['ring-offset-blue', '100']\n// ['ring-offset', 'blue-100']\n// ['ring', 'offset-blue-100']\n// Example with dynamic classes:\n// ['grid-cols', '[[linename],1fr,auto]']\n// ['grid', 'cols-[[linename],1fr,auto]']\nfunction* candidatePermutations(candidate) {\n    let lastIndex = Infinity;\n    while(lastIndex >= 0){\n        let dashIdx;\n        let wasSlash = false;\n        if (lastIndex === Infinity && candidate.endsWith(\"]\")) {\n            let bracketIdx = candidate.indexOf(\"[\");\n            // If character before `[` isn't a dash or a slash, this isn't a dynamic class\n            // eg. string[]\n            if (candidate[bracketIdx - 1] === \"-\") {\n                dashIdx = bracketIdx - 1;\n            } else if (candidate[bracketIdx - 1] === \"/\") {\n                dashIdx = bracketIdx - 1;\n                wasSlash = true;\n            } else {\n                dashIdx = -1;\n            }\n        } else if (lastIndex === Infinity && candidate.includes(\"/\")) {\n            dashIdx = candidate.lastIndexOf(\"/\");\n            wasSlash = true;\n        } else {\n            dashIdx = candidate.lastIndexOf(\"-\", lastIndex);\n        }\n        if (dashIdx < 0) {\n            break;\n        }\n        let prefix = candidate.slice(0, dashIdx);\n        let modifier = candidate.slice(wasSlash ? dashIdx : dashIdx + 1);\n        lastIndex = dashIdx - 1;\n        // TODO: This feels a bit hacky\n        if (prefix === \"\" || modifier === \"/\") {\n            continue;\n        }\n        yield [\n            prefix,\n            modifier\n        ];\n    }\n}\nfunction applyPrefix(matches, context) {\n    if (matches.length === 0 || context.tailwindConfig.prefix === \"\") {\n        return matches;\n    }\n    for (let match of matches){\n        let [meta] = match;\n        if (meta.options.respectPrefix) {\n            let container = _postcss.default.root({\n                nodes: [\n                    match[1].clone()\n                ]\n            });\n            let classCandidate = match[1].raws.tailwind.classCandidate;\n            container.walkRules((r)=>{\n                // If this is a negative utility with a dash *before* the prefix we\n                // have to ensure that the generated selector matches the candidate\n                // Not doing this will cause `-tw-top-1` to generate the class `.tw--top-1`\n                // The disconnect between candidate <-> class can cause @apply to hard crash.\n                let shouldPrependNegative = classCandidate.startsWith(\"-\");\n                r.selector = (0, _prefixSelector.default)(context.tailwindConfig.prefix, r.selector, shouldPrependNegative);\n            });\n            match[1] = container.nodes[0];\n        }\n    }\n    return matches;\n}\nfunction applyImportant(matches, classCandidate) {\n    if (matches.length === 0) {\n        return matches;\n    }\n    let result = [];\n    function isInKeyframes(rule) {\n        return rule.parent && rule.parent.type === \"atrule\" && rule.parent.name === \"keyframes\";\n    }\n    for (let [meta, rule] of matches){\n        let container = _postcss.default.root({\n            nodes: [\n                rule.clone()\n            ]\n        });\n        container.walkRules((r)=>{\n            // Declarations inside keyframes cannot be marked as important\n            // They will be ignored by the browser\n            if (isInKeyframes(r)) {\n                return;\n            }\n            let ast = (0, _postcssselectorparser.default)().astSync(r.selector);\n            // Remove extraneous selectors that do not include the base candidate\n            ast.each((sel)=>(0, _formatVariantSelector.eliminateIrrelevantSelectors)(sel, classCandidate));\n            // Update all instances of the base candidate to include the important marker\n            (0, _pluginUtils.updateAllClasses)(ast, (className)=>className === classCandidate ? `!${className}` : className);\n            r.selector = ast.toString();\n            r.walkDecls((d)=>d.important = true);\n        });\n        result.push([\n            {\n                ...meta,\n                important: true\n            },\n            container.nodes[0]\n        ]);\n    }\n    return result;\n}\n// Takes a list of rule tuples and applies a variant like `hover`, sm`,\n// whatever to it. We used to do some extra caching here to avoid generating\n// a variant of the same rule more than once, but this was never hit because\n// we cache at the entire selector level further up the tree.\n//\n// Technically you can get a cache hit if you have `hover:focus:text-center`\n// and `focus:hover:text-center` in the same project, but it doesn't feel\n// worth the complexity for that case.\nfunction applyVariant(variant, matches, context) {\n    if (matches.length === 0) {\n        return matches;\n    }\n    /** @type {{modifier: string | null, value: string | null}} */ let args = {\n        modifier: null,\n        value: _sharedState.NONE\n    };\n    // Retrieve \"modifier\"\n    {\n        let [baseVariant, ...modifiers] = (0, _splitAtTopLevelOnly.splitAtTopLevelOnly)(variant, \"/\");\n        // This is a hack to support variants with `/` in them, like `ar-1/10/20:text-red-500`\n        // In this case 1/10 is a value but /20 is a modifier\n        if (modifiers.length > 1) {\n            baseVariant = baseVariant + \"/\" + modifiers.slice(0, -1).join(\"/\");\n            modifiers = modifiers.slice(-1);\n        }\n        if (modifiers.length && !context.variantMap.has(variant)) {\n            variant = baseVariant;\n            args.modifier = modifiers[0];\n            if (!(0, _featureFlags.flagEnabled)(context.tailwindConfig, \"generalizedModifiers\")) {\n                return [];\n            }\n        }\n    }\n    // Retrieve \"arbitrary value\"\n    if (variant.endsWith(\"]\") && !variant.startsWith(\"[\")) {\n        // We either have:\n        //   @[200px]\n        //   group-[:hover]\n        //\n        // But we don't want:\n        //   @-[200px]        (`-` is incorrect)\n        //   group[:hover]    (`-` is missing)\n        let match = /(.)(-?)\\[(.*)\\]/g.exec(variant);\n        if (match) {\n            let [, char, separator, value] = match;\n            // @-[200px] case\n            if (char === \"@\" && separator === \"-\") return [];\n            // group[:hover] case\n            if (char !== \"@\" && separator === \"\") return [];\n            variant = variant.replace(`${separator}[${value}]`, \"\");\n            args.value = value;\n        }\n    }\n    // Register arbitrary variants\n    if (isArbitraryValue(variant) && !context.variantMap.has(variant)) {\n        let sort = context.offsets.recordVariant(variant);\n        let selector = (0, _dataTypes.normalize)(variant.slice(1, -1));\n        let selectors = (0, _splitAtTopLevelOnly.splitAtTopLevelOnly)(selector, \",\");\n        // We do not support multiple selectors for arbitrary variants\n        if (selectors.length > 1) {\n            return [];\n        }\n        if (!selectors.every(_setupContextUtils.isValidVariantFormatString)) {\n            return [];\n        }\n        let records = selectors.map((sel, idx)=>[\n                context.offsets.applyParallelOffset(sort, idx),\n                (0, _setupContextUtils.parseVariant)(sel.trim())\n            ]);\n        context.variantMap.set(variant, records);\n    }\n    if (context.variantMap.has(variant)) {\n        var _context_variantOptions_get;\n        let isArbitraryVariant = isArbitraryValue(variant);\n        var _context_variantOptions_get_INTERNAL_FEATURES;\n        let internalFeatures = (_context_variantOptions_get_INTERNAL_FEATURES = (_context_variantOptions_get = context.variantOptions.get(variant)) === null || _context_variantOptions_get === void 0 ? void 0 : _context_variantOptions_get[_setupContextUtils.INTERNAL_FEATURES]) !== null && _context_variantOptions_get_INTERNAL_FEATURES !== void 0 ? _context_variantOptions_get_INTERNAL_FEATURES : {};\n        let variantFunctionTuples = context.variantMap.get(variant).slice();\n        let result = [];\n        let respectPrefix = (()=>{\n            if (isArbitraryVariant) return false;\n            if (internalFeatures.respectPrefix === false) return false;\n            return true;\n        })();\n        for (let [meta, rule] of matches){\n            // Don't generate variants for user css\n            if (meta.layer === \"user\") {\n                continue;\n            }\n            let container = _postcss.default.root({\n                nodes: [\n                    rule.clone()\n                ]\n            });\n            for (let [variantSort, variantFunction, containerFromArray] of variantFunctionTuples){\n                let clone = (containerFromArray !== null && containerFromArray !== void 0 ? containerFromArray : container).clone();\n                let collectedFormats = [];\n                function prepareBackup() {\n                    // Already prepared, chicken out\n                    if (clone.raws.neededBackup) {\n                        return;\n                    }\n                    clone.raws.neededBackup = true;\n                    clone.walkRules((rule)=>rule.raws.originalSelector = rule.selector);\n                }\n                function modifySelectors(modifierFunction) {\n                    prepareBackup();\n                    clone.each((rule)=>{\n                        if (rule.type !== \"rule\") {\n                            return;\n                        }\n                        rule.selectors = rule.selectors.map((selector)=>{\n                            return modifierFunction({\n                                get className () {\n                                    return getClassNameFromSelector(selector);\n                                },\n                                selector\n                            });\n                        });\n                    });\n                    return clone;\n                }\n                let ruleWithVariant = variantFunction({\n                    // Public API\n                    get container () {\n                        prepareBackup();\n                        return clone;\n                    },\n                    separator: context.tailwindConfig.separator,\n                    modifySelectors,\n                    // Private API for now\n                    wrap (wrapper) {\n                        let nodes = clone.nodes;\n                        clone.removeAll();\n                        wrapper.append(nodes);\n                        clone.append(wrapper);\n                    },\n                    format (selectorFormat) {\n                        collectedFormats.push({\n                            format: selectorFormat,\n                            respectPrefix\n                        });\n                    },\n                    args\n                });\n                // It can happen that a list of format strings is returned from within the function. In that\n                // case, we have to process them as well. We can use the existing `variantSort`.\n                if (Array.isArray(ruleWithVariant)) {\n                    for (let [idx, variantFunction] of ruleWithVariant.entries()){\n                        // This is a little bit scary since we are pushing to an array of items that we are\n                        // currently looping over. However, you can also think of it like a processing queue\n                        // where you keep handling jobs until everything is done and each job can queue more\n                        // jobs if needed.\n                        variantFunctionTuples.push([\n                            context.offsets.applyParallelOffset(variantSort, idx),\n                            variantFunction,\n                            // If the clone has been modified we have to pass that back\n                            // though so each rule can use the modified container\n                            clone.clone()\n                        ]);\n                    }\n                    continue;\n                }\n                if (typeof ruleWithVariant === \"string\") {\n                    collectedFormats.push({\n                        format: ruleWithVariant,\n                        respectPrefix\n                    });\n                }\n                if (ruleWithVariant === null) {\n                    continue;\n                }\n                // We had to backup selectors, therefore we assume that somebody touched\n                // `container` or `modifySelectors`. Let's see if they did, so that we\n                // can restore the selectors, and collect the format strings.\n                if (clone.raws.neededBackup) {\n                    delete clone.raws.neededBackup;\n                    clone.walkRules((rule)=>{\n                        let before = rule.raws.originalSelector;\n                        if (!before) return;\n                        delete rule.raws.originalSelector;\n                        if (before === rule.selector) return; // No mutation happened\n                        let modified = rule.selector;\n                        // Rebuild the base selector, this is what plugin authors would do\n                        // as well. E.g.: `${variant}${separator}${className}`.\n                        // However, plugin authors probably also prepend or append certain\n                        // classes, pseudos, ids, ...\n                        let rebuiltBase = (0, _postcssselectorparser.default)((selectors)=>{\n                            selectors.walkClasses((classNode)=>{\n                                classNode.value = `${variant}${context.tailwindConfig.separator}${classNode.value}`;\n                            });\n                        }).processSync(before);\n                        // Now that we know the original selector, the new selector, and\n                        // the rebuild part in between, we can replace the part that plugin\n                        // authors need to rebuild with `&`, and eventually store it in the\n                        // collectedFormats. Similar to what `format('...')` would do.\n                        //\n                        // E.g.:\n                        //                   variant: foo\n                        //                  selector: .markdown > p\n                        //      modified (by plugin): .foo .foo\\\\:markdown > p\n                        //    rebuiltBase (internal): .foo\\\\:markdown > p\n                        //                    format: .foo &\n                        collectedFormats.push({\n                            format: modified.replace(rebuiltBase, \"&\"),\n                            respectPrefix\n                        });\n                        rule.selector = before;\n                    });\n                }\n                // This tracks the originating layer for the variant\n                // For example:\n                // .sm:underline {} is a variant of something in the utilities layer\n                // .sm:container {} is a variant of the container component\n                clone.nodes[0].raws.tailwind = {\n                    ...clone.nodes[0].raws.tailwind,\n                    parentLayer: meta.layer\n                };\n                var _meta_collectedFormats;\n                let withOffset = [\n                    {\n                        ...meta,\n                        sort: context.offsets.applyVariantOffset(meta.sort, variantSort, Object.assign(args, context.variantOptions.get(variant))),\n                        collectedFormats: ((_meta_collectedFormats = meta.collectedFormats) !== null && _meta_collectedFormats !== void 0 ? _meta_collectedFormats : []).concat(collectedFormats)\n                    },\n                    clone.nodes[0]\n                ];\n                result.push(withOffset);\n            }\n        }\n        return result;\n    }\n    return [];\n}\nfunction parseRules(rule, cache, options = {}) {\n    // PostCSS node\n    if (!(0, _isPlainObject.default)(rule) && !Array.isArray(rule)) {\n        return [\n            [\n                rule\n            ],\n            options\n        ];\n    }\n    // Tuple\n    if (Array.isArray(rule)) {\n        return parseRules(rule[0], cache, rule[1]);\n    }\n    // Simple object\n    if (!cache.has(rule)) {\n        cache.set(rule, (0, _parseObjectStyles.default)(rule));\n    }\n    return [\n        cache.get(rule),\n        options\n    ];\n}\nconst IS_VALID_PROPERTY_NAME = /^[a-z_-]/;\nfunction isValidPropName(name) {\n    return IS_VALID_PROPERTY_NAME.test(name);\n}\n/**\n * @param {string} declaration\n * @returns {boolean}\n */ function looksLikeUri(declaration) {\n    // Quick bailout for obvious non-urls\n    // This doesn't support schemes that don't use a leading // but that's unlikely to be a problem\n    if (!declaration.includes(\"://\")) {\n        return false;\n    }\n    try {\n        const url = new URL(declaration);\n        return url.scheme !== \"\" && url.host !== \"\";\n    } catch (err) {\n        // Definitely not a valid url\n        return false;\n    }\n}\nfunction isParsableNode(node) {\n    let isParsable = true;\n    node.walkDecls((decl)=>{\n        if (!isParsableCssValue(decl.prop, decl.value)) {\n            isParsable = false;\n            return false;\n        }\n    });\n    return isParsable;\n}\nfunction isParsableCssValue(property, value) {\n    // We don't want to to treat [https://example.com] as a custom property\n    // Even though, according to the CSS grammar, it's a totally valid CSS declaration\n    // So we short-circuit here by checking if the custom property looks like a url\n    if (looksLikeUri(`${property}:${value}`)) {\n        return false;\n    }\n    try {\n        _postcss.default.parse(`a{${property}:${value}}`).toResult();\n        return true;\n    } catch (err) {\n        return false;\n    }\n}\nfunction extractArbitraryProperty(classCandidate, context) {\n    var _classCandidate_match;\n    let [, property, value] = (_classCandidate_match = classCandidate.match(/^\\[([a-zA-Z0-9-_]+):(\\S+)\\]$/)) !== null && _classCandidate_match !== void 0 ? _classCandidate_match : [];\n    if (value === undefined) {\n        return null;\n    }\n    if (!isValidPropName(property)) {\n        return null;\n    }\n    if (!(0, _isSyntacticallyValidPropertyValue.default)(value)) {\n        return null;\n    }\n    let normalized = (0, _dataTypes.normalize)(value, {\n        property\n    });\n    if (!isParsableCssValue(property, normalized)) {\n        return null;\n    }\n    let sort = context.offsets.arbitraryProperty(classCandidate);\n    return [\n        [\n            {\n                sort,\n                layer: \"utilities\",\n                options: {\n                    respectImportant: true\n                }\n            },\n            ()=>({\n                    [(0, _nameClass.asClass)(classCandidate)]: {\n                        [property]: normalized\n                    }\n                })\n        ]\n    ];\n}\nfunction* resolveMatchedPlugins(classCandidate, context) {\n    if (context.candidateRuleMap.has(classCandidate)) {\n        yield [\n            context.candidateRuleMap.get(classCandidate),\n            \"DEFAULT\"\n        ];\n    }\n    yield* function*(arbitraryPropertyRule) {\n        if (arbitraryPropertyRule !== null) {\n            yield [\n                arbitraryPropertyRule,\n                \"DEFAULT\"\n            ];\n        }\n    }(extractArbitraryProperty(classCandidate, context));\n    let candidatePrefix = classCandidate;\n    let negative = false;\n    const twConfigPrefix = context.tailwindConfig.prefix;\n    const twConfigPrefixLen = twConfigPrefix.length;\n    const hasMatchingPrefix = candidatePrefix.startsWith(twConfigPrefix) || candidatePrefix.startsWith(`-${twConfigPrefix}`);\n    if (candidatePrefix[twConfigPrefixLen] === \"-\" && hasMatchingPrefix) {\n        negative = true;\n        candidatePrefix = twConfigPrefix + candidatePrefix.slice(twConfigPrefixLen + 1);\n    }\n    if (negative && context.candidateRuleMap.has(candidatePrefix)) {\n        yield [\n            context.candidateRuleMap.get(candidatePrefix),\n            \"-DEFAULT\"\n        ];\n    }\n    for (let [prefix, modifier] of candidatePermutations(candidatePrefix)){\n        if (context.candidateRuleMap.has(prefix)) {\n            yield [\n                context.candidateRuleMap.get(prefix),\n                negative ? `-${modifier}` : modifier\n            ];\n        }\n    }\n}\nfunction splitWithSeparator(input, separator) {\n    if (input === _sharedState.NOT_ON_DEMAND) {\n        return [\n            _sharedState.NOT_ON_DEMAND\n        ];\n    }\n    return (0, _splitAtTopLevelOnly.splitAtTopLevelOnly)(input, separator);\n}\nfunction* recordCandidates(matches, classCandidate) {\n    for (const match of matches){\n        var _match__options;\n        var _match__options_preserveSource;\n        match[1].raws.tailwind = {\n            ...match[1].raws.tailwind,\n            classCandidate,\n            preserveSource: (_match__options_preserveSource = (_match__options = match[0].options) === null || _match__options === void 0 ? void 0 : _match__options.preserveSource) !== null && _match__options_preserveSource !== void 0 ? _match__options_preserveSource : false\n        };\n        yield match;\n    }\n}\nfunction* resolveMatches(candidate, context) {\n    let separator = context.tailwindConfig.separator;\n    let [classCandidate, ...variants] = splitWithSeparator(candidate, separator).reverse();\n    let important = false;\n    if (classCandidate.startsWith(\"!\")) {\n        important = true;\n        classCandidate = classCandidate.slice(1);\n    }\n    // TODO: Reintroduce this in ways that doesn't break on false positives\n    // function sortAgainst(toSort, against) {\n    //   return toSort.slice().sort((a, z) => {\n    //     return bigSign(against.get(a)[0] - against.get(z)[0])\n    //   })\n    // }\n    // let sorted = sortAgainst(variants, context.variantMap)\n    // if (sorted.toString() !== variants.toString()) {\n    //   let corrected = sorted.reverse().concat(classCandidate).join(':')\n    //   throw new Error(`Class ${candidate} should be written as ${corrected}`)\n    // }\n    for (let matchedPlugins of resolveMatchedPlugins(classCandidate, context)){\n        let matches = [];\n        let typesByMatches = new Map();\n        let [plugins, modifier] = matchedPlugins;\n        let isOnlyPlugin = plugins.length === 1;\n        for (let [sort, plugin] of plugins){\n            let matchesPerPlugin = [];\n            if (typeof plugin === \"function\") {\n                for (let ruleSet of [].concat(plugin(modifier, {\n                    isOnlyPlugin\n                }))){\n                    let [rules, options] = parseRules(ruleSet, context.postCssNodeCache);\n                    for (let rule of rules){\n                        matchesPerPlugin.push([\n                            {\n                                ...sort,\n                                options: {\n                                    ...sort.options,\n                                    ...options\n                                }\n                            },\n                            rule\n                        ]);\n                    }\n                }\n            } else if (modifier === \"DEFAULT\" || modifier === \"-DEFAULT\") {\n                let ruleSet = plugin;\n                let [rules, options] = parseRules(ruleSet, context.postCssNodeCache);\n                for (let rule of rules){\n                    matchesPerPlugin.push([\n                        {\n                            ...sort,\n                            options: {\n                                ...sort.options,\n                                ...options\n                            }\n                        },\n                        rule\n                    ]);\n                }\n            }\n            if (matchesPerPlugin.length > 0) {\n                var _sort_options;\n                var _sort_options_types, _sort_options1;\n                let matchingTypes = Array.from((0, _pluginUtils.getMatchingTypes)((_sort_options_types = (_sort_options = sort.options) === null || _sort_options === void 0 ? void 0 : _sort_options.types) !== null && _sort_options_types !== void 0 ? _sort_options_types : [], modifier, (_sort_options1 = sort.options) !== null && _sort_options1 !== void 0 ? _sort_options1 : {}, context.tailwindConfig)).map(([_, type])=>type);\n                if (matchingTypes.length > 0) {\n                    typesByMatches.set(matchesPerPlugin, matchingTypes);\n                }\n                matches.push(matchesPerPlugin);\n            }\n        }\n        if (isArbitraryValue(modifier)) {\n            if (matches.length > 1) {\n                // Partition plugins in 2 categories so that we can start searching in the plugins that\n                // don't have `any` as a type first.\n                let [withAny, withoutAny] = matches.reduce((group, plugin)=>{\n                    let hasAnyType = plugin.some(([{ options  }])=>options.types.some(({ type  })=>type === \"any\"));\n                    if (hasAnyType) {\n                        group[0].push(plugin);\n                    } else {\n                        group[1].push(plugin);\n                    }\n                    return group;\n                }, [\n                    [],\n                    []\n                ]);\n                function findFallback(matches) {\n                    // If only a single plugin matches, let's take that one\n                    if (matches.length === 1) {\n                        return matches[0];\n                    }\n                    // Otherwise, find the plugin that creates a valid rule given the arbitrary value, and\n                    // also has the correct type which preferOnConflicts the plugin in case of clashes.\n                    return matches.find((rules)=>{\n                        let matchingTypes = typesByMatches.get(rules);\n                        return rules.some(([{ options  }, rule])=>{\n                            if (!isParsableNode(rule)) {\n                                return false;\n                            }\n                            return options.types.some(({ type , preferOnConflict  })=>matchingTypes.includes(type) && preferOnConflict);\n                        });\n                    });\n                }\n                var _findFallback;\n                // Try to find a fallback plugin, because we already know that multiple plugins matched for\n                // the given arbitrary value.\n                let fallback = (_findFallback = findFallback(withoutAny)) !== null && _findFallback !== void 0 ? _findFallback : findFallback(withAny);\n                if (fallback) {\n                    matches = [\n                        fallback\n                    ];\n                } else {\n                    var _typesByMatches_get;\n                    let typesPerPlugin = matches.map((match)=>new Set([\n                            ...(_typesByMatches_get = typesByMatches.get(match)) !== null && _typesByMatches_get !== void 0 ? _typesByMatches_get : []\n                        ]));\n                    // Remove duplicates, so that we can detect proper unique types for each plugin.\n                    for (let pluginTypes of typesPerPlugin){\n                        for (let type of pluginTypes){\n                            let removeFromOwnGroup = false;\n                            for (let otherGroup of typesPerPlugin){\n                                if (pluginTypes === otherGroup) continue;\n                                if (otherGroup.has(type)) {\n                                    otherGroup.delete(type);\n                                    removeFromOwnGroup = true;\n                                }\n                            }\n                            if (removeFromOwnGroup) pluginTypes.delete(type);\n                        }\n                    }\n                    let messages = [];\n                    for (let [idx, group] of typesPerPlugin.entries()){\n                        for (let type of group){\n                            let rules = matches[idx].map(([, rule])=>rule).flat().map((rule)=>rule.toString().split(\"\\n\").slice(1, -1) // Remove selector and closing '}'\n                                .map((line)=>line.trim()).map((x)=>`      ${x}`) // Re-indent\n                                .join(\"\\n\")).join(\"\\n\\n\");\n                            messages.push(`  Use \\`${candidate.replace(\"[\", `[${type}:`)}\\` for \\`${rules.trim()}\\``);\n                            break;\n                        }\n                    }\n                    _log.default.warn([\n                        `The class \\`${candidate}\\` is ambiguous and matches multiple utilities.`,\n                        ...messages,\n                        `If this is content and not a class, replace it with \\`${candidate.replace(\"[\", \"&lsqb;\").replace(\"]\", \"&rsqb;\")}\\` to silence this warning.`\n                    ]);\n                    continue;\n                }\n            }\n            matches = matches.map((list)=>list.filter((match)=>isParsableNode(match[1])));\n        }\n        matches = matches.flat();\n        matches = Array.from(recordCandidates(matches, classCandidate));\n        matches = applyPrefix(matches, context);\n        if (important) {\n            matches = applyImportant(matches, classCandidate);\n        }\n        for (let variant of variants){\n            matches = applyVariant(variant, matches, context);\n        }\n        for (let match of matches){\n            match[1].raws.tailwind = {\n                ...match[1].raws.tailwind,\n                candidate\n            };\n            // Apply final format selector\n            match = applyFinalFormat(match, {\n                context,\n                candidate\n            });\n            // Skip rules with invalid selectors\n            // This will cause the candidate to be added to the \"not class\"\n            // cache skipping it entirely for future builds\n            if (match === null) {\n                continue;\n            }\n            yield match;\n        }\n    }\n}\nfunction applyFinalFormat(match, { context , candidate  }) {\n    if (!match[0].collectedFormats) {\n        return match;\n    }\n    let isValid = true;\n    let finalFormat;\n    try {\n        finalFormat = (0, _formatVariantSelector.formatVariantSelector)(match[0].collectedFormats, {\n            context,\n            candidate\n        });\n    } catch  {\n        // The format selector we produced is invalid\n        // This could be because:\n        // - A bug exists\n        // - A plugin introduced an invalid variant selector (ex: `addVariant('foo', '&;foo')`)\n        // - The user used an invalid arbitrary variant (ex: `[&;foo]:underline`)\n        // Either way the build will fail because of this\n        // We would rather that the build pass \"silently\" given that this could\n        // happen because of picking up invalid things when scanning content\n        // So we'll throw out the candidate instead\n        return null;\n    }\n    let container = _postcss.default.root({\n        nodes: [\n            match[1].clone()\n        ]\n    });\n    container.walkRules((rule)=>{\n        if (inKeyframes(rule)) {\n            return;\n        }\n        try {\n            let selector = (0, _formatVariantSelector.finalizeSelector)(rule.selector, finalFormat, {\n                candidate,\n                context\n            });\n            // Finalize Selector determined that this candidate is irrelevant\n            // TODO: This elimination should happen earlier so this never happens\n            if (selector === null) {\n                rule.remove();\n                return;\n            }\n            rule.selector = selector;\n        } catch  {\n            // If this selector is invalid we also want to skip it\n            // But it's likely that being invalid here means there's a bug in a plugin rather than too loosely matching content\n            isValid = false;\n            return false;\n        }\n    });\n    if (!isValid) {\n        return null;\n    }\n    // If all rules have been eliminated we can skip this candidate entirely\n    if (container.nodes.length === 0) {\n        return null;\n    }\n    match[1] = container.nodes[0];\n    return match;\n}\nfunction inKeyframes(rule) {\n    return rule.parent && rule.parent.type === \"atrule\" && rule.parent.name === \"keyframes\";\n}\nfunction getImportantStrategy(important) {\n    if (important === true) {\n        return (rule)=>{\n            if (inKeyframes(rule)) {\n                return;\n            }\n            rule.walkDecls((d)=>{\n                if (d.parent.type === \"rule\" && !inKeyframes(d.parent)) {\n                    d.important = true;\n                }\n            });\n        };\n    }\n    if (typeof important === \"string\") {\n        return (rule)=>{\n            if (inKeyframes(rule)) {\n                return;\n            }\n            rule.selectors = rule.selectors.map((selector)=>{\n                return (0, _applyImportantSelector.applyImportantSelector)(selector, important);\n            });\n        };\n    }\n}\nfunction generateRules(candidates, context, isSorting = false) {\n    let allRules = [];\n    let strategy = getImportantStrategy(context.tailwindConfig.important);\n    for (let candidate of candidates){\n        if (context.notClassCache.has(candidate)) {\n            continue;\n        }\n        if (context.candidateRuleCache.has(candidate)) {\n            allRules = allRules.concat(Array.from(context.candidateRuleCache.get(candidate)));\n            continue;\n        }\n        let matches = Array.from(resolveMatches(candidate, context));\n        if (matches.length === 0) {\n            context.notClassCache.add(candidate);\n            continue;\n        }\n        context.classCache.set(candidate, matches);\n        var _context_candidateRuleCache_get;\n        let rules = (_context_candidateRuleCache_get = context.candidateRuleCache.get(candidate)) !== null && _context_candidateRuleCache_get !== void 0 ? _context_candidateRuleCache_get : new Set();\n        context.candidateRuleCache.set(candidate, rules);\n        for (const match of matches){\n            let [{ sort , options  }, rule] = match;\n            if (options.respectImportant && strategy) {\n                let container = _postcss.default.root({\n                    nodes: [\n                        rule.clone()\n                    ]\n                });\n                container.walkRules(strategy);\n                rule = container.nodes[0];\n            }\n            // Note: We have to clone rules during sorting\n            // so we eliminate some shared mutable state\n            let newEntry = [\n                sort,\n                isSorting ? rule.clone() : rule\n            ];\n            rules.add(newEntry);\n            context.ruleCache.add(newEntry);\n            allRules.push(newEntry);\n        }\n    }\n    return allRules;\n}\nfunction isArbitraryValue(input) {\n    return input.startsWith(\"[\") && input.endsWith(\"]\");\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}