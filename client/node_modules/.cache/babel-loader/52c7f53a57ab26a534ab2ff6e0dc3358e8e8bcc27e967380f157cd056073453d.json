{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"default\", {\n  enumerable: true,\n  get: function () {\n    return expandTailwindAtRules;\n  }\n});\nconst _fs = /*#__PURE__*/_interop_require_default(require(\"fs\"));\nconst _quicklru = /*#__PURE__*/_interop_require_default(require(\"@alloc/quick-lru\"));\nconst _sharedState = /*#__PURE__*/_interop_require_wildcard(require(\"./sharedState\"));\nconst _generateRules = require(\"./generateRules\");\nconst _log = /*#__PURE__*/_interop_require_default(require(\"../util/log\"));\nconst _cloneNodes = /*#__PURE__*/_interop_require_default(require(\"../util/cloneNodes\"));\nconst _defaultExtractor = require(\"./defaultExtractor\");\nfunction _interop_require_default(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== \"function\") return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function (nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\nfunction _interop_require_wildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n  var cache = _getRequireWildcardCache(nodeInterop);\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n  for (var key in obj) {\n    if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n  newObj.default = obj;\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n  return newObj;\n}\nlet env = _sharedState.env;\nconst builtInExtractors = {\n  DEFAULT: _defaultExtractor.defaultExtractor\n};\nconst builtInTransformers = {\n  DEFAULT: content => content,\n  svelte: content => content.replace(/(?:^|\\s)class:/g, \" \")\n};\nfunction getExtractor(context, fileExtension) {\n  let extractors = context.tailwindConfig.content.extract;\n  return extractors[fileExtension] || extractors.DEFAULT || builtInExtractors[fileExtension] || builtInExtractors.DEFAULT(context);\n}\nfunction getTransformer(tailwindConfig, fileExtension) {\n  let transformers = tailwindConfig.content.transform;\n  return transformers[fileExtension] || transformers.DEFAULT || builtInTransformers[fileExtension] || builtInTransformers.DEFAULT;\n}\nlet extractorCache = new WeakMap();\n// Scans template contents for possible classes. This is a hot path on initial build but\n// not too important for subsequent builds. The faster the better though â€” if we can speed\n// up these regexes by 50% that could cut initial build time by like 20%.\nfunction getClassCandidates(content, extractor, candidates, seen) {\n  if (!extractorCache.has(extractor)) {\n    extractorCache.set(extractor, new _quicklru.default({\n      maxSize: 25000\n    }));\n  }\n  for (let line of content.split(\"\\n\")) {\n    line = line.trim();\n    if (seen.has(line)) {\n      continue;\n    }\n    seen.add(line);\n    if (extractorCache.get(extractor).has(line)) {\n      for (let match of extractorCache.get(extractor).get(line)) {\n        candidates.add(match);\n      }\n    } else {\n      let extractorMatches = extractor(line).filter(s => s !== \"!*\");\n      let lineMatchesSet = new Set(extractorMatches);\n      for (let match of lineMatchesSet) {\n        candidates.add(match);\n      }\n      extractorCache.get(extractor).set(line, lineMatchesSet);\n    }\n  }\n}\n/**\n *\n * @param {[import('./offsets.js').RuleOffset, import('postcss').Node][]} rules\n * @param {*} context\n */\nfunction buildStylesheet(rules, context) {\n  let sortedRules = context.offsets.sort(rules);\n  let returnValue = {\n    base: new Set(),\n    defaults: new Set(),\n    components: new Set(),\n    utilities: new Set(),\n    variants: new Set()\n  };\n  for (let [sort, rule] of sortedRules) {\n    returnValue[sort.layer].add(rule);\n  }\n  return returnValue;\n}\nfunction expandTailwindAtRules(context) {\n  return async root => {\n    let layerNodes = {\n      base: null,\n      components: null,\n      utilities: null,\n      variants: null\n    };\n    root.walkAtRules(rule => {\n      // Make sure this file contains Tailwind directives. If not, we can save\n      // a lot of work and bail early. Also we don't have to register our touch\n      // file as a dependency since the output of this CSS does not depend on\n      // the source of any templates. Think Vue <style> blocks for example.\n      if (rule.name === \"tailwind\") {\n        if (Object.keys(layerNodes).includes(rule.params)) {\n          layerNodes[rule.params] = rule;\n        }\n      }\n    });\n    if (Object.values(layerNodes).every(n => n === null)) {\n      return root;\n    }\n    var _context_candidates;\n    // ---\n    // Find potential rules in changed files\n    let candidates = new Set([...((_context_candidates = context.candidates) !== null && _context_candidates !== void 0 ? _context_candidates : []), _sharedState.NOT_ON_DEMAND]);\n    let seen = new Set();\n    env.DEBUG && console.time(\"Reading changed files\");\n    /** @type {[item: {file?: string, content?: string}, meta: {transformer: any, extractor: any}][]} */\n    let regexParserContent = [];\n    for (let item of context.changedContent) {\n      let transformer = getTransformer(context.tailwindConfig, item.extension);\n      let extractor = getExtractor(context, item.extension);\n      regexParserContent.push([item, {\n        transformer,\n        extractor\n      }]);\n    }\n    const BATCH_SIZE = 500;\n    for (let i = 0; i < regexParserContent.length; i += BATCH_SIZE) {\n      let batch = regexParserContent.slice(i, i + BATCH_SIZE);\n      await Promise.all(batch.map(async ([{\n        file,\n        content\n      }, {\n        transformer,\n        extractor\n      }]) => {\n        content = file ? await _fs.default.promises.readFile(file, \"utf8\") : content;\n        getClassCandidates(transformer(content), extractor, candidates, seen);\n      }));\n    }\n    env.DEBUG && console.timeEnd(\"Reading changed files\");\n    // ---\n    // Generate the actual CSS\n    let classCacheCount = context.classCache.size;\n    env.DEBUG && console.time(\"Generate rules\");\n    env.DEBUG && console.time(\"Sorting candidates\");\n    let sortedCandidates = new Set([...candidates].sort((a, z) => {\n      if (a === z) return 0;\n      if (a < z) return -1;\n      return 1;\n    }));\n    env.DEBUG && console.timeEnd(\"Sorting candidates\");\n    (0, _generateRules.generateRules)(sortedCandidates, context);\n    env.DEBUG && console.timeEnd(\"Generate rules\");\n    // We only ever add to the classCache, so if it didn't grow, there is nothing new.\n    env.DEBUG && console.time(\"Build stylesheet\");\n    if (context.stylesheetCache === null || context.classCache.size !== classCacheCount) {\n      context.stylesheetCache = buildStylesheet([...context.ruleCache], context);\n    }\n    env.DEBUG && console.timeEnd(\"Build stylesheet\");\n    let {\n      defaults: defaultNodes,\n      base: baseNodes,\n      components: componentNodes,\n      utilities: utilityNodes,\n      variants: screenNodes\n    } = context.stylesheetCache;\n    // ---\n    // Replace any Tailwind directives with generated CSS\n    if (layerNodes.base) {\n      layerNodes.base.before((0, _cloneNodes.default)([...defaultNodes, ...baseNodes], layerNodes.base.source, {\n        layer: \"base\"\n      }));\n      layerNodes.base.remove();\n    }\n    if (layerNodes.components) {\n      layerNodes.components.before((0, _cloneNodes.default)([...componentNodes], layerNodes.components.source, {\n        layer: \"components\"\n      }));\n      layerNodes.components.remove();\n    }\n    if (layerNodes.utilities) {\n      layerNodes.utilities.before((0, _cloneNodes.default)([...utilityNodes], layerNodes.utilities.source, {\n        layer: \"utilities\"\n      }));\n      layerNodes.utilities.remove();\n    }\n    // We do post-filtering to not alter the emitted order of the variants\n    const variantNodes = Array.from(screenNodes).filter(node => {\n      var _node_raws_tailwind;\n      const parentLayer = (_node_raws_tailwind = node.raws.tailwind) === null || _node_raws_tailwind === void 0 ? void 0 : _node_raws_tailwind.parentLayer;\n      if (parentLayer === \"components\") {\n        return layerNodes.components !== null;\n      }\n      if (parentLayer === \"utilities\") {\n        return layerNodes.utilities !== null;\n      }\n      return true;\n    });\n    if (layerNodes.variants) {\n      layerNodes.variants.before((0, _cloneNodes.default)(variantNodes, layerNodes.variants.source, {\n        layer: \"variants\"\n      }));\n      layerNodes.variants.remove();\n    } else if (variantNodes.length > 0) {\n      root.append((0, _cloneNodes.default)(variantNodes, root.source, {\n        layer: \"variants\"\n      }));\n    }\n    var _root_source_end;\n    // TODO: Why is the root node having no source location for `end` possible?\n    root.source.end = (_root_source_end = root.source.end) !== null && _root_source_end !== void 0 ? _root_source_end : root.source.start;\n    // If we've got a utility layer and no utilities are generated there's likely something wrong\n    const hasUtilityVariants = variantNodes.some(node => {\n      var _node_raws_tailwind;\n      return ((_node_raws_tailwind = node.raws.tailwind) === null || _node_raws_tailwind === void 0 ? void 0 : _node_raws_tailwind.parentLayer) === \"utilities\";\n    });\n    if (layerNodes.utilities && utilityNodes.size === 0 && !hasUtilityVariants) {\n      _log.default.warn(\"content-problems\", [\"No utility classes were detected in your source files. If this is unexpected, double-check the `content` option in your Tailwind CSS configuration.\", \"https://tailwindcss.com/docs/content-configuration\"]);\n    }\n    // ---\n    if (env.DEBUG) {\n      console.log(\"Potential classes: \", candidates.size);\n      console.log(\"Active contexts: \", _sharedState.contextSourcesMap.size);\n    }\n    // Clear the cache for the changed files\n    context.changedContent = [];\n    // Cleanup any leftover @layer atrules\n    root.walkAtRules(\"layer\", rule => {\n      if (Object.keys(layerNodes).includes(rule.params)) {\n        rule.remove();\n      }\n    });\n  };\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","enumerable","get","expandTailwindAtRules","_fs","_interop_require_default","require","_quicklru","_sharedState","_interop_require_wildcard","_generateRules","_log","_cloneNodes","_defaultExtractor","obj","__esModule","default","_getRequireWildcardCache","nodeInterop","WeakMap","cacheBabelInterop","cacheNodeInterop","cache","has","newObj","hasPropertyDescriptor","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","env","builtInExtractors","DEFAULT","defaultExtractor","builtInTransformers","content","svelte","replace","getExtractor","context","fileExtension","extractors","tailwindConfig","extract","getTransformer","transformers","transform","extractorCache","getClassCandidates","extractor","candidates","seen","maxSize","line","split","trim","add","match","extractorMatches","filter","s","lineMatchesSet","Set","buildStylesheet","rules","sortedRules","offsets","sort","returnValue","base","defaults","components","utilities","variants","rule","layer","root","layerNodes","walkAtRules","name","keys","includes","params","values","every","n","_context_candidates","NOT_ON_DEMAND","DEBUG","console","time","regexParserContent","item","changedContent","transformer","extension","push","BATCH_SIZE","i","length","batch","slice","Promise","all","map","file","promises","readFile","timeEnd","classCacheCount","classCache","size","sortedCandidates","a","z","generateRules","stylesheetCache","ruleCache","defaultNodes","baseNodes","componentNodes","utilityNodes","screenNodes","before","source","remove","variantNodes","Array","from","node","_node_raws_tailwind","parentLayer","raws","tailwind","append","_root_source_end","end","start","hasUtilityVariants","some","warn","log","contextSourcesMap"],"sources":["/Users/zeynepbas/Desktop/stackowerflow/node_modules/tailwindcss/lib/lib/expandTailwindAtRules.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"default\", {\n    enumerable: true,\n    get: function() {\n        return expandTailwindAtRules;\n    }\n});\nconst _fs = /*#__PURE__*/ _interop_require_default(require(\"fs\"));\nconst _quicklru = /*#__PURE__*/ _interop_require_default(require(\"@alloc/quick-lru\"));\nconst _sharedState = /*#__PURE__*/ _interop_require_wildcard(require(\"./sharedState\"));\nconst _generateRules = require(\"./generateRules\");\nconst _log = /*#__PURE__*/ _interop_require_default(require(\"../util/log\"));\nconst _cloneNodes = /*#__PURE__*/ _interop_require_default(require(\"../util/cloneNodes\"));\nconst _defaultExtractor = require(\"./defaultExtractor\");\nfunction _interop_require_default(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nfunction _getRequireWildcardCache(nodeInterop) {\n    if (typeof WeakMap !== \"function\") return null;\n    var cacheBabelInterop = new WeakMap();\n    var cacheNodeInterop = new WeakMap();\n    return (_getRequireWildcardCache = function(nodeInterop) {\n        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n    })(nodeInterop);\n}\nfunction _interop_require_wildcard(obj, nodeInterop) {\n    if (!nodeInterop && obj && obj.__esModule) {\n        return obj;\n    }\n    if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n        return {\n            default: obj\n        };\n    }\n    var cache = _getRequireWildcardCache(nodeInterop);\n    if (cache && cache.has(obj)) {\n        return cache.get(obj);\n    }\n    var newObj = {};\n    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for(var key in obj){\n        if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n            if (desc && (desc.get || desc.set)) {\n                Object.defineProperty(newObj, key, desc);\n            } else {\n                newObj[key] = obj[key];\n            }\n        }\n    }\n    newObj.default = obj;\n    if (cache) {\n        cache.set(obj, newObj);\n    }\n    return newObj;\n}\nlet env = _sharedState.env;\nconst builtInExtractors = {\n    DEFAULT: _defaultExtractor.defaultExtractor\n};\nconst builtInTransformers = {\n    DEFAULT: (content)=>content,\n    svelte: (content)=>content.replace(/(?:^|\\s)class:/g, \" \")\n};\nfunction getExtractor(context, fileExtension) {\n    let extractors = context.tailwindConfig.content.extract;\n    return extractors[fileExtension] || extractors.DEFAULT || builtInExtractors[fileExtension] || builtInExtractors.DEFAULT(context);\n}\nfunction getTransformer(tailwindConfig, fileExtension) {\n    let transformers = tailwindConfig.content.transform;\n    return transformers[fileExtension] || transformers.DEFAULT || builtInTransformers[fileExtension] || builtInTransformers.DEFAULT;\n}\nlet extractorCache = new WeakMap();\n// Scans template contents for possible classes. This is a hot path on initial build but\n// not too important for subsequent builds. The faster the better though â€” if we can speed\n// up these regexes by 50% that could cut initial build time by like 20%.\nfunction getClassCandidates(content, extractor, candidates, seen) {\n    if (!extractorCache.has(extractor)) {\n        extractorCache.set(extractor, new _quicklru.default({\n            maxSize: 25000\n        }));\n    }\n    for (let line of content.split(\"\\n\")){\n        line = line.trim();\n        if (seen.has(line)) {\n            continue;\n        }\n        seen.add(line);\n        if (extractorCache.get(extractor).has(line)) {\n            for (let match of extractorCache.get(extractor).get(line)){\n                candidates.add(match);\n            }\n        } else {\n            let extractorMatches = extractor(line).filter((s)=>s !== \"!*\");\n            let lineMatchesSet = new Set(extractorMatches);\n            for (let match of lineMatchesSet){\n                candidates.add(match);\n            }\n            extractorCache.get(extractor).set(line, lineMatchesSet);\n        }\n    }\n}\n/**\n *\n * @param {[import('./offsets.js').RuleOffset, import('postcss').Node][]} rules\n * @param {*} context\n */ function buildStylesheet(rules, context) {\n    let sortedRules = context.offsets.sort(rules);\n    let returnValue = {\n        base: new Set(),\n        defaults: new Set(),\n        components: new Set(),\n        utilities: new Set(),\n        variants: new Set()\n    };\n    for (let [sort, rule] of sortedRules){\n        returnValue[sort.layer].add(rule);\n    }\n    return returnValue;\n}\nfunction expandTailwindAtRules(context) {\n    return async (root)=>{\n        let layerNodes = {\n            base: null,\n            components: null,\n            utilities: null,\n            variants: null\n        };\n        root.walkAtRules((rule)=>{\n            // Make sure this file contains Tailwind directives. If not, we can save\n            // a lot of work and bail early. Also we don't have to register our touch\n            // file as a dependency since the output of this CSS does not depend on\n            // the source of any templates. Think Vue <style> blocks for example.\n            if (rule.name === \"tailwind\") {\n                if (Object.keys(layerNodes).includes(rule.params)) {\n                    layerNodes[rule.params] = rule;\n                }\n            }\n        });\n        if (Object.values(layerNodes).every((n)=>n === null)) {\n            return root;\n        }\n        var _context_candidates;\n        // ---\n        // Find potential rules in changed files\n        let candidates = new Set([\n            ...(_context_candidates = context.candidates) !== null && _context_candidates !== void 0 ? _context_candidates : [],\n            _sharedState.NOT_ON_DEMAND\n        ]);\n        let seen = new Set();\n        env.DEBUG && console.time(\"Reading changed files\");\n        /** @type {[item: {file?: string, content?: string}, meta: {transformer: any, extractor: any}][]} */ let regexParserContent = [];\n        for (let item of context.changedContent){\n            let transformer = getTransformer(context.tailwindConfig, item.extension);\n            let extractor = getExtractor(context, item.extension);\n            regexParserContent.push([\n                item,\n                {\n                    transformer,\n                    extractor\n                }\n            ]);\n        }\n        const BATCH_SIZE = 500;\n        for(let i = 0; i < regexParserContent.length; i += BATCH_SIZE){\n            let batch = regexParserContent.slice(i, i + BATCH_SIZE);\n            await Promise.all(batch.map(async ([{ file , content  }, { transformer , extractor  }])=>{\n                content = file ? await _fs.default.promises.readFile(file, \"utf8\") : content;\n                getClassCandidates(transformer(content), extractor, candidates, seen);\n            }));\n        }\n        env.DEBUG && console.timeEnd(\"Reading changed files\");\n        // ---\n        // Generate the actual CSS\n        let classCacheCount = context.classCache.size;\n        env.DEBUG && console.time(\"Generate rules\");\n        env.DEBUG && console.time(\"Sorting candidates\");\n        let sortedCandidates = new Set([\n            ...candidates\n        ].sort((a, z)=>{\n            if (a === z) return 0;\n            if (a < z) return -1;\n            return 1;\n        }));\n        env.DEBUG && console.timeEnd(\"Sorting candidates\");\n        (0, _generateRules.generateRules)(sortedCandidates, context);\n        env.DEBUG && console.timeEnd(\"Generate rules\");\n        // We only ever add to the classCache, so if it didn't grow, there is nothing new.\n        env.DEBUG && console.time(\"Build stylesheet\");\n        if (context.stylesheetCache === null || context.classCache.size !== classCacheCount) {\n            context.stylesheetCache = buildStylesheet([\n                ...context.ruleCache\n            ], context);\n        }\n        env.DEBUG && console.timeEnd(\"Build stylesheet\");\n        let { defaults: defaultNodes , base: baseNodes , components: componentNodes , utilities: utilityNodes , variants: screenNodes  } = context.stylesheetCache;\n        // ---\n        // Replace any Tailwind directives with generated CSS\n        if (layerNodes.base) {\n            layerNodes.base.before((0, _cloneNodes.default)([\n                ...defaultNodes,\n                ...baseNodes\n            ], layerNodes.base.source, {\n                layer: \"base\"\n            }));\n            layerNodes.base.remove();\n        }\n        if (layerNodes.components) {\n            layerNodes.components.before((0, _cloneNodes.default)([\n                ...componentNodes\n            ], layerNodes.components.source, {\n                layer: \"components\"\n            }));\n            layerNodes.components.remove();\n        }\n        if (layerNodes.utilities) {\n            layerNodes.utilities.before((0, _cloneNodes.default)([\n                ...utilityNodes\n            ], layerNodes.utilities.source, {\n                layer: \"utilities\"\n            }));\n            layerNodes.utilities.remove();\n        }\n        // We do post-filtering to not alter the emitted order of the variants\n        const variantNodes = Array.from(screenNodes).filter((node)=>{\n            var _node_raws_tailwind;\n            const parentLayer = (_node_raws_tailwind = node.raws.tailwind) === null || _node_raws_tailwind === void 0 ? void 0 : _node_raws_tailwind.parentLayer;\n            if (parentLayer === \"components\") {\n                return layerNodes.components !== null;\n            }\n            if (parentLayer === \"utilities\") {\n                return layerNodes.utilities !== null;\n            }\n            return true;\n        });\n        if (layerNodes.variants) {\n            layerNodes.variants.before((0, _cloneNodes.default)(variantNodes, layerNodes.variants.source, {\n                layer: \"variants\"\n            }));\n            layerNodes.variants.remove();\n        } else if (variantNodes.length > 0) {\n            root.append((0, _cloneNodes.default)(variantNodes, root.source, {\n                layer: \"variants\"\n            }));\n        }\n        var _root_source_end;\n        // TODO: Why is the root node having no source location for `end` possible?\n        root.source.end = (_root_source_end = root.source.end) !== null && _root_source_end !== void 0 ? _root_source_end : root.source.start;\n        // If we've got a utility layer and no utilities are generated there's likely something wrong\n        const hasUtilityVariants = variantNodes.some((node)=>{\n            var _node_raws_tailwind;\n            return ((_node_raws_tailwind = node.raws.tailwind) === null || _node_raws_tailwind === void 0 ? void 0 : _node_raws_tailwind.parentLayer) === \"utilities\";\n        });\n        if (layerNodes.utilities && utilityNodes.size === 0 && !hasUtilityVariants) {\n            _log.default.warn(\"content-problems\", [\n                \"No utility classes were detected in your source files. If this is unexpected, double-check the `content` option in your Tailwind CSS configuration.\",\n                \"https://tailwindcss.com/docs/content-configuration\"\n            ]);\n        }\n        // ---\n        if (env.DEBUG) {\n            console.log(\"Potential classes: \", candidates.size);\n            console.log(\"Active contexts: \", _sharedState.contextSourcesMap.size);\n        }\n        // Clear the cache for the changed files\n        context.changedContent = [];\n        // Cleanup any leftover @layer atrules\n        root.walkAtRules(\"layer\", (rule)=>{\n            if (Object.keys(layerNodes).includes(rule.params)) {\n                rule.remove();\n            }\n        });\n    };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}